diff --git a/lib/index.d.ts b/lib/index.d.ts
index f39badbc4e5cdc04ef24512ee15925ade7ae2944..9a4b06b5092efc6211bdfb5b6277293bc54d62f1 100644
--- a/lib/index.d.ts
+++ b/lib/index.d.ts
@@ -1,41 +1,40 @@
-import { RenderRule } from "markdown-it/lib/renderer.mjs";
-import { PluginWithOptions } from "markdown-it";
+import type { PluginWithOptions, RenderRule } from 'markdown-exit';
 
 //#region src/options.d.ts
 interface MarkdownItAlertOptions {
   /**
-   * Allowed alert names
-   *
-   * 允许的警告名称
-   *
-   * @default ['important', 'note', 'tip', 'warning', 'caution']
-   */
+  * Allowed alert names
+  *
+  * 允许的警告名称
+  *
+  * @default ['important', 'note', 'tip', 'warning', 'caution']
+  */
   alertNames?: string[];
   /**
-   * Whether handle deep alert syntax
-   *
-   * 是否允许深层的警告语法
-   *
-   * @default false
-   */
+  * Whether handle deep alert syntax
+  *
+  * 是否允许深层的警告语法
+  *
+  * @default false
+  */
   deep?: boolean;
   /**
-   * Hint opening tag render function
-   *
-   * 提示开始标签渲染函数
-   */
+  * Hint opening tag render function
+  *
+  * 提示开始标签渲染函数
+  */
   openRender?: RenderRule;
   /**
-   * Hint closing tag render function
-   *
-   * 提示结束标签渲染函数
-   */
+  * Hint closing tag render function
+  *
+  * 提示结束标签渲染函数
+  */
   closeRender?: RenderRule;
   /**
-   * Hint title render function
-   *
-   * 提示标题渲染函数
-   */
+  * Hint title render function
+  *
+  * 提示标题渲染函数
+  */
   titleRender?: RenderRule;
 }
 //#endregion
diff --git a/lib/index.js b/lib/index.js
index b2de4690c04738108df4988d55d4f7702352d005..1d398c0ecf7f63062e0d29f70d52ad8538f0d2e8 100644
--- a/lib/index.js
+++ b/lib/index.js
@@ -1,2 +1,2 @@
-const e=(e,t)=>(n,r,i,a)=>{if(n.sCount[r]-n.blkIndent>=4||n.level!==0&&!t)return!1;let o=n.bMarks[r]+n.tShift[r],s=n.eMarks[r];if(n.src.charCodeAt(o)!==62)return!1;let c=o+1,l=n.sCount[r]+1,u=!1;n.src.charCodeAt(c)===32?(c++,l++):n.src.charCodeAt(c)===9&&((n.bsCount[r]+l)%4==3?(c++,l++):u=!0);let d=l;for(;c<s;){let e=n.src.charCodeAt(c);if(e===9)d+=4-(d+n.bsCount[r]+(u?1:0))%4;else if(e===32)d++;else break;c++}if(d-l>=4||s-c<4||n.src.charCodeAt(c)!==91||n.src.charCodeAt(c+1)!==33)return!1;c+=2;let f=``;for(;c<s;){let e=n.src.charAt(c);if(e===`]`)break;f+=e,c++}if(c===s)return!1;let p=f.toLowerCase();if(!e.has(p)||(c=n.skipSpaces(c+1),c<s))return!1;let m=[],h=[],g=[],_=[],v=n.lineMax,y=n.parentType,b=[n.md.block.ruler.getRules(`blockquote`),n.md.block.ruler.getRules(`alert`)].flat();n.parentType=`alert`;let x=r,S=!1;for(;x<i;x++){let e=n.sCount[x]<n.blkIndent,t=n.bMarks[x]+n.tShift[x],r=n.eMarks[x];if(t>=r)break;if(n.src.charCodeAt(t++)===62&&!e){let e=n.sCount[x]+1,i=!1,o=!1;n.src.charCodeAt(t)===32?(t++,e++,i=!0):n.src.charCodeAt(t)===9&&(i=!0,(n.bsCount[x]+e)%4==3?(t++,e++):o=!0);let s=e;for(a||(m.push(n.bMarks[x]),n.bMarks[x]=t);t<r;){let e=n.src.charCodeAt(t);if(e===9)s+=4-(s+n.bsCount[x]+(o?1:0))%4;else if(e===32)s++;else break;t++}S=t>=r,a||(h.push(n.bsCount[x]),n.bsCount[x]=n.sCount[x]+1+(i?1:0),g.push(n.sCount[x]),n.sCount[x]=s-e,_.push(n.tShift[x]),n.tShift[x]=t-n.bMarks[x]);continue}if(S)break;let o=!1,s=b.length;for(let e=0;e<s;e++){let t=b[e];if(t(n,x,i,!0)){o=!0;break}}if(o){n.lineMax=x,n.blkIndent!==0&&!a&&(m.push(n.bMarks[x]),h.push(n.bsCount[x]),g.push(n.sCount[x]),_.push(n.tShift[x]),n.sCount[x]-=n.blkIndent);break}a||(m.push(n.bMarks[x]),h.push(n.bsCount[x]),g.push(n.sCount[x]),_.push(n.tShift[x]),n.sCount[x]=-1)}let C=()=>{n.lineMax=v,n.parentType=y;for(let e=0;e<_.length;e++)n.bMarks[e+r]=m[e],n.tShift[e+r]=_[e],n.sCount[e+r]=g[e],n.bsCount[e+r]=h[e]};if(r+1>=x)return a||C(),!1;if(a)return!0;let w=n.blkIndent;n.blkIndent=0;let T=[r,r+1],E=[r+1,0],D=n.push(`alert_open`,`div`,1);D.markup=p,D.attrJoin(`class`,`markdown-alert markdown-alert-${p}`),D.map=E;let O=n.push(`alert_title`,``,0);O.attrJoin(`class`,`markdown-alert-title`),O.markup=p,O.content=f,O.map=T,n.md.block.tokenize(n,r+1,x);let k=n.push(`alert_close`,`div`,-1);return k.markup=p,E[1]=n.line,n.blkIndent=w,C(),!0},t=(t,{alertNames:n=[`tip`,`warning`,`caution`,`important`,`note`],deep:r=!1,openRender:i,closeRender:a,titleRender:o}={})=>{t.block.ruler.before(`blockquote`,`alert`,e(new Set(n.map(e=>e.toLowerCase())),r),{alt:[`paragraph`,`reference`,`blockquote`,`list`]}),i&&(t.renderer.rules.alert_open=i),a&&(t.renderer.rules.alert_close=a),t.renderer.rules.alert_title=o??((e,t)=>{let n=e[t];return`<p class="markdown-alert-title">${n.content[0].toUpperCase()+n.content.slice(1).toLowerCase()}</p>\n`})};export{t as alert};
+const e=(e,t)=>(n,r,i,a)=>{if(a&&n.parentType===`alert`||n.sCount[r]-n.blkIndent>=4||n.level!==0&&!t)return!1;let o=n.bMarks[r]+n.tShift[r],s=n.eMarks[r];if(n.src.charCodeAt(o)!==62)return!1;let c=o+1,l=n.sCount[r]+1,u=!1;n.src.charCodeAt(c)===32?(c++,l++):n.src.charCodeAt(c)===9&&((n.bsCount[r]+l)%4==3?(c++,l++):u=!0);let d=l;for(;c<s;){let e=n.src.charCodeAt(c);if(e===9)d+=4-(d+n.bsCount[r]+(u?1:0))%4;else if(e===32)d++;else break;c++}if(d-l>=4||s-c<4||n.src.charCodeAt(c)!==91||n.src.charCodeAt(c+1)!==33)return!1;c+=2;let f=``;for(;c<s;){let e=n.src.charAt(c);if(e===`]`)break;f+=e,c++}if(c===s)return!1;let p=f.toLowerCase();if(!e.has(p)||(c=n.skipSpaces(c+1),c<s))return!1;let m=[],h=[],g=[],_=[],v=n.lineMax,y=n.parentType,b=[n.md.block.ruler.getRules(`blockquote`),n.md.block.ruler.getRules(`alert`)].flat();n.parentType=`alert`;let x=r,S=!1,C=!1;for(;x<i;x++){let e=n.sCount[x]<n.blkIndent,t=n.bMarks[x]+n.tShift[x],o=n.eMarks[x];if(t>=o)break;if(n.src.charCodeAt(t++)===62&&!e){let e=n.sCount[x]+1,i=!1,s=!1;n.src.charCodeAt(t)===32?(t++,e++,i=!0):n.src.charCodeAt(t)===9&&(i=!0,(n.bsCount[x]+e)%4==3?(t++,e++):s=!0);let c=e;for(a||(m.push(n.bMarks[x]),n.bMarks[x]=t);t<o;){let e=n.src.charCodeAt(t);if(e===9)c+=4-(c+n.bsCount[x]+(s?1:0))%4;else if(e===32)c++;else break;t++}S=t>=o,x>r&&!S&&(C=!0),a||(h.push(n.bsCount[x]),n.bsCount[x]=n.sCount[x]+1+(i?1:0),g.push(n.sCount[x]),n.sCount[x]=c-e,_.push(n.tShift[x]),n.tShift[x]=t-n.bMarks[x]);continue}if(S)break;let s=!1,c=b.length;for(let e=0;e<c;e++){let t=b[e];if(t(n,x,i,!0)){s=!0;break}}if(s){n.lineMax=x,n.blkIndent!==0&&!a&&(m.push(n.bMarks[x]),h.push(n.bsCount[x]),g.push(n.sCount[x]),_.push(n.tShift[x]),n.sCount[x]-=n.blkIndent);break}C=!0,a||(m.push(n.bMarks[x]),h.push(n.bsCount[x]),g.push(n.sCount[x]),_.push(n.tShift[x]),x>r+1&&(n.sCount[x]=-1))}let w=()=>{n.lineMax=v,n.parentType=y;for(let e=0;e<_.length;e++)n.bMarks[e+r]=m[e],n.tShift[e+r]=_[e],n.sCount[e+r]=g[e],n.bsCount[e+r]=h[e]};if(r+1>=x||!C)return a||w(),!1;if(a)return!0;let T=n.blkIndent;n.blkIndent=0;let E=[r,r+1],D=[r+1,0],O=n.push(`alert_open`,`div`,1);O.markup=p,O.attrJoin(`class`,`markdown-alert markdown-alert-${p}`),O.map=D;let k=n.push(`alert_title`,``,0);k.attrJoin(`class`,`markdown-alert-title`),k.markup=p,k.content=f,k.map=E,n.md.block.tokenize(n,r+1,x);let A=n.push(`alert_close`,`div`,-1);return A.markup=p,D[1]=n.line,n.blkIndent=T,w(),!0},t=(t,{alertNames:n=[`tip`,`warning`,`caution`,`important`,`note`],deep:r=!1,openRender:i,closeRender:a,titleRender:o}={})=>{t.block.ruler.before(`blockquote`,`alert`,e(new Set(n.map(e=>e.toLowerCase())),r),{alt:[`paragraph`,`reference`,`blockquote`,`list`]}),i&&(t.renderer.rules.alert_open=i),a&&(t.renderer.rules.alert_close=a),t.renderer.rules.alert_title=o??((e,t)=>{let n=e[t];return`<p class="markdown-alert-title">${n.content[0].toUpperCase()+n.content.slice(1).toLowerCase()}</p>\n`})};export{t as alert};
 //# sourceMappingURL=index.js.map
diff --git a/lib/index.js.map b/lib/index.js.map
index 0e132c1b9b1825ee5cb4f37c9f308ea0df003098..67d34ad6543e9bb3fb89264a523703840938b6b7 100644
--- a/lib/index.js.map
+++ b/lib/index.js.map
@@ -1 +1 @@
-{"version":3,"file":"index.js","names":[],"sources":["../src/plugins.ts"],"sourcesContent":["import type { PluginWithOptions } from \"markdown-it\";\nimport type { RuleBlock } from \"markdown-it/lib/parser_block.mjs\";\n\nimport type { MarkdownItAlertOptions } from \"./options.js\";\n\nconst getAlertRule =\n  // oxlint-disable-next-line max-lines-per-function\n  (types: Set<string>, deep: boolean): RuleBlock =>\n    // oxlint-disable-next-line max-lines-per-function\n    (state, startLine, endLine, silent) => {\n      if (\n        // if it's indented more than 3 spaces, it should be a code block\n        state.sCount[startLine] - state.blkIndent >= 4 ||\n        // check whether it's at first level\n        (state.level !== 0 && !deep)\n      )\n        return false;\n\n      const pos = state.bMarks[startLine] + state.tShift[startLine];\n      const max = state.eMarks[startLine];\n\n      // check the block quote marker\n      if (state.src.charCodeAt(pos) !== 62 /* > */) return false;\n\n      let currentPos = pos + 1;\n\n      let initial = state.sCount[startLine] + 1;\n      let adjustTab = false;\n\n      // skip one optional space after '>'\n      if (state.src.charCodeAt(currentPos) === 32 /* space */) {\n        // ' >   [!tip] '\n        //     ^ -- position start of line here:\n        currentPos++;\n        initial++;\n      } else if (state.src.charCodeAt(currentPos) === 9 /* tab */) {\n        if ((state.bsCount[startLine] + initial) % 4 === 3) {\n          // '  >\\t  [!tip] '\n          //       ^ -- position start of line here (tab has width===1)\n          currentPos++;\n          initial++;\n        } else {\n          // ' >\\t  [!tip] '\n          //    ^ -- position start of line here + shift bsCount slightly\n          //         to make extra space appear\n          adjustTab = true;\n        }\n      }\n\n      let offset = initial;\n\n      while (currentPos < max) {\n        const ch = state.src.charCodeAt(currentPos);\n\n        if (ch === 9 /** \\t */)\n          offset += 4 - ((offset + state.bsCount[startLine] + (adjustTab ? 1 : 0)) % 4);\n        else if (ch === 32 /** space */) offset++;\n        else break;\n\n        currentPos++;\n      }\n\n      // skip blockquote\n      if (offset - initial >= 4) return false;\n\n      // the minimum length of an alert is 4 characters [!x]\n      if (max - currentPos < 4) return false;\n\n      // check opening marker '[!'\n      if (\n        state.src.charCodeAt(currentPos) !== 91 /* [ */ ||\n        state.src.charCodeAt(currentPos + 1) !== 33 /* ! */\n      )\n        return false;\n\n      currentPos += 2;\n\n      let typeName = \"\";\n\n      // find closing bracket ']'\n      while (currentPos < max) {\n        const char = state.src.charAt(currentPos);\n\n        if (char === \"]\") break;\n\n        typeName += char;\n        currentPos++;\n      }\n\n      if (currentPos === max) return false;\n\n      const type = typeName.toLowerCase();\n\n      if (!types.has(type)) return false;\n\n      // skip spaces after ']'\n      currentPos = state.skipSpaces(currentPos + 1);\n\n      // if there are non-space characters after ']', it's not a valid alert\n      if (currentPos < max) return false;\n\n      const oldBMarks: number[] = [];\n      const oldBSCount: number[] = [];\n      const oldSCount: number[] = [];\n      const oldTShift: number[] = [];\n      const oldLineMax = state.lineMax;\n      const oldParentType = state.parentType;\n      const terminatorRules = [\n        state.md.block.ruler.getRules(\"blockquote\"),\n        state.md.block.ruler.getRules(\"alert\"),\n      ].flat();\n\n      // @ts-expect-error: We are creating a new type called \"alert\"\n      state.parentType = \"alert\";\n\n      // Search the end of the block\n      //\n      // Block ends with either:\n      //  1. an empty line outside:\n      //     ```\n      //     > test\n      //\n      //     ```\n      //  2. an empty line inside:\n      //     ```\n      //     >\n      //     test\n      //     ```\n      //  3. another tag:\n      //     ```\n      //     > test\n      //      - - -\n      //     ```\n      let currentLine = startLine;\n      let lastLineEmpty = false;\n\n      for (; currentLine < endLine; currentLine++) {\n        // check if it's outdented, i.e. it's inside list item and indented\n        // less than said list item:\n        //\n        // ```\n        // 1. anything\n        //    > current blockquote\n        // 2. checking this line\n        // ```\n        const isOutdented = state.sCount[currentLine] < state.blkIndent;\n\n        let pos = state.bMarks[currentLine] + state.tShift[currentLine];\n        const max = state.eMarks[currentLine];\n\n        // Case 1: line is not inside the blockquote, and this line is empty.\n        if (pos >= max) break;\n\n        if (state.src.charCodeAt(pos++) === 62 /* > */ && !isOutdented) {\n          // This line is inside the blockquote.\n\n          // set offset past spaces and \">\"\n          let initial = state.sCount[currentLine] + 1;\n          let spaceAfterMarker = false;\n          let adjustTab = false;\n\n          // skip one optional space after '>'\n          if (state.src.charCodeAt(pos) === 32 /* space */) {\n            // ' >   test '\n            //     ^ -- position start of line here:\n            pos++;\n            initial++;\n            spaceAfterMarker = true;\n          } else if (state.src.charCodeAt(pos) === 9 /* \\t */) {\n            spaceAfterMarker = true;\n\n            if ((state.bsCount[currentLine] + initial) % 4 === 3) {\n              // '  >\\t  test '\n              //       ^ -- position start of line here (tab has width===1)\n              pos++;\n              initial++;\n            } else {\n              // ' >\\t  test '\n              //    ^ -- position start of line here + shift bsCount slightly\n              //         to make extra space appear\n              adjustTab = true;\n            }\n          }\n\n          let offset = initial;\n\n          if (!silent) {\n            oldBMarks.push(state.bMarks[currentLine]);\n            state.bMarks[currentLine] = pos;\n          }\n\n          while (pos < max) {\n            const ch = state.src.charCodeAt(pos);\n\n            if (ch === 9 /** \\t */)\n              offset += 4 - ((offset + state.bsCount[currentLine] + (adjustTab ? 1 : 0)) % 4);\n            else if (ch === 32 /** space */) offset++;\n            else break;\n\n            pos++;\n          }\n\n          lastLineEmpty = pos >= max;\n\n          if (!silent) {\n            oldBSCount.push(state.bsCount[currentLine]);\n            state.bsCount[currentLine] = state.sCount[currentLine] + 1 + (spaceAfterMarker ? 1 : 0);\n\n            oldSCount.push(state.sCount[currentLine]);\n            state.sCount[currentLine] = offset - initial;\n\n            oldTShift.push(state.tShift[currentLine]);\n            state.tShift[currentLine] = pos - state.bMarks[currentLine];\n          }\n          continue;\n        }\n\n        // Case 2: line is not inside the blockquote, and the last line was empty.\n        // oxlint-disable-next-line typescript/no-unnecessary-condition\n        if (lastLineEmpty) break;\n\n        // Case 3: another tag found.\n        let terminate = false;\n\n        const terminateRuleLength = terminatorRules.length;\n\n        for (let i = 0; i < terminateRuleLength; i++) {\n          const terminatorRule = terminatorRules[i];\n\n          if (terminatorRule(state, currentLine, endLine, true)) {\n            terminate = true;\n            break;\n          }\n        }\n\n        if (terminate) {\n          // Quirk to enforce \"hard termination mode\" for paragraphs;\n          // normally if you call `tokenize(state, startLine, nextLine)`,\n          // paragraphs will look below nextLine for paragraph continuation,\n          // but if blockquote is terminated by another tag, they shouldn't\n          state.lineMax = currentLine;\n\n          if (state.blkIndent !== 0 && !silent) {\n            // state.blkIndent was non-zero, we now set it to zero,\n            // so we need to re-calculate all offsets to appear as\n            // if indent wasn't changed\n            oldBMarks.push(state.bMarks[currentLine]);\n            oldBSCount.push(state.bsCount[currentLine]);\n            oldSCount.push(state.sCount[currentLine]);\n            oldTShift.push(state.tShift[currentLine]);\n\n            state.sCount[currentLine] -= state.blkIndent;\n          }\n\n          break;\n        }\n\n        if (!silent) {\n          oldBMarks.push(state.bMarks[currentLine]);\n          oldBSCount.push(state.bsCount[currentLine]);\n          oldSCount.push(state.sCount[currentLine]);\n          oldTShift.push(state.tShift[currentLine]);\n\n          // A negative indentation means that this is a paragraph continuation\n          state.sCount[currentLine] = -1;\n        }\n      }\n\n      const restoreState = (): void => {\n        state.lineMax = oldLineMax;\n        state.parentType = oldParentType;\n\n        // Restore original tShift; this might not be necessary since the parser\n        // has already been here, but just to make sure we can do that.\n        for (let i = 0; i < oldTShift.length; i++) {\n          state.bMarks[i + startLine] = oldBMarks[i];\n          state.tShift[i + startLine] = oldTShift[i];\n          state.sCount[i + startLine] = oldSCount[i];\n          state.bsCount[i + startLine] = oldBSCount[i];\n        }\n      };\n\n      // If we didn't find any alert body, so we don't have a valid alert\n      if (startLine + 1 >= currentLine) {\n        // If we are in silent mode, we don't need to restore the state\n        if (!silent) restoreState();\n\n        return false;\n      }\n\n      // from now we know that it's going to be a valid alert,\n      // so no point trying to find the end of it in silent mode\n      if (silent) return true;\n\n      const oldIndent = state.blkIndent;\n\n      state.blkIndent = 0;\n\n      const titleLines: [number, number] = [startLine, startLine + 1];\n      const contentLines: [number, number] = [startLine + 1, 0];\n\n      const openToken = state.push(\"alert_open\", \"div\", 1);\n\n      openToken.markup = type;\n      openToken.attrJoin(\"class\", `markdown-alert markdown-alert-${type}`);\n      openToken.map = contentLines;\n\n      const titleToken = state.push(\"alert_title\", \"\", 0);\n\n      titleToken.attrJoin(\"class\", `markdown-alert-title`);\n      titleToken.markup = type;\n      titleToken.content = typeName;\n      titleToken.map = titleLines;\n\n      state.md.block.tokenize(state, startLine + 1, currentLine);\n\n      const closeToken = state.push(\"alert_close\", \"div\", -1);\n\n      closeToken.markup = type;\n      contentLines[1] = state.line;\n\n      state.blkIndent = oldIndent;\n      restoreState();\n\n      return true;\n    };\n\nexport const alert: PluginWithOptions<MarkdownItAlertOptions> = (\n  md,\n  {\n    alertNames = [\"tip\", \"warning\", \"caution\", \"important\", \"note\"],\n    deep = false,\n    openRender,\n    closeRender,\n    titleRender,\n  } = {},\n) => {\n  md.block.ruler.before(\n    \"blockquote\",\n    \"alert\",\n    getAlertRule(new Set(alertNames.map((name) => name.toLowerCase())), deep),\n    {\n      alt: [\"paragraph\", \"reference\", \"blockquote\", \"list\"],\n    },\n  );\n\n  if (openRender) md.renderer.rules.alert_open = openRender;\n\n  if (closeRender) md.renderer.rules.alert_close = closeRender;\n\n  md.renderer.rules.alert_title =\n    titleRender ??\n    ((tokens, index): string => {\n      const token = tokens[index];\n\n      return `<p class=\"markdown-alert-title\">${\n        token.content[0].toUpperCase() + token.content.slice(1).toLowerCase()\n      }</p>\\n`;\n    });\n};\n"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"index.js","names":[],"sources":["../src/plugins.ts"],"sourcesContent":["import type { PluginWithOptions } from \"markdown-it\";\nimport type { RuleBlock } from \"markdown-it/lib/parser_block.mjs\";\nimport type { ParentType } from \"markdown-it/lib/rules_block/state_block.mjs\";\n\nimport type { MarkdownItAlertOptions } from \"./options.js\";\n\nconst getAlertRule =\n  // oxlint-disable-next-line max-lines-per-function\n  (types: Set<string>, deep: boolean): RuleBlock =>\n    // oxlint-disable-next-line max-lines-per-function\n    (state, startLine, endLine, silent) => {\n      // Prevent recursive silent re-entry when alert rule is invoked\n      // as a terminator while already parsing an alert block.\n      // This avoids stack overflows while preserving deep nesting in normal parse mode.\n      if (silent && (state.parentType as ParentType & \"alert\") === \"alert\") return false;\n\n      if (\n        // if it's indented more than 3 spaces, it should be a code block\n        state.sCount[startLine] - state.blkIndent >= 4 ||\n        // check whether it's at first level\n        (state.level !== 0 && !deep)\n      )\n        return false;\n\n      const pos = state.bMarks[startLine] + state.tShift[startLine];\n      const max = state.eMarks[startLine];\n\n      // check the block quote marker\n      if (state.src.charCodeAt(pos) !== 62 /* > */) return false;\n\n      let currentPos = pos + 1;\n\n      let initial = state.sCount[startLine] + 1;\n      let adjustTab = false;\n\n      // skip one optional space after '>'\n      if (state.src.charCodeAt(currentPos) === 32 /* space */) {\n        // ' >   [!tip] '\n        //     ^ -- position start of line here:\n        currentPos++;\n        initial++;\n      } else if (state.src.charCodeAt(currentPos) === 9 /* tab */) {\n        if ((state.bsCount[startLine] + initial) % 4 === 3) {\n          // '  >\\t  [!tip] '\n          //       ^ -- position start of line here (tab has width===1)\n          currentPos++;\n          initial++;\n        } else {\n          // ' >\\t  [!tip] '\n          //    ^ -- position start of line here + shift bsCount slightly\n          //         to make extra space appear\n          adjustTab = true;\n        }\n      }\n\n      let offset = initial;\n\n      while (currentPos < max) {\n        const ch = state.src.charCodeAt(currentPos);\n\n        if (ch === 9 /** \\t */)\n          offset += 4 - ((offset + state.bsCount[startLine] + (adjustTab ? 1 : 0)) % 4);\n        else if (ch === 32 /** space */) offset++;\n        else break;\n\n        currentPos++;\n      }\n\n      // skip blockquote\n      if (offset - initial >= 4) return false;\n\n      // the minimum length of an alert is 4 characters [!x]\n      if (max - currentPos < 4) return false;\n\n      // check opening marker '[!'\n      if (\n        state.src.charCodeAt(currentPos) !== 91 /* [ */ ||\n        state.src.charCodeAt(currentPos + 1) !== 33 /* ! */\n      )\n        return false;\n\n      currentPos += 2;\n\n      let typeName = \"\";\n\n      // find closing bracket ']'\n      while (currentPos < max) {\n        const char = state.src.charAt(currentPos);\n\n        if (char === \"]\") break;\n\n        typeName += char;\n        currentPos++;\n      }\n\n      if (currentPos === max) return false;\n\n      const type = typeName.toLowerCase();\n\n      if (!types.has(type)) return false;\n\n      // skip spaces after ']'\n      currentPos = state.skipSpaces(currentPos + 1);\n\n      // if there are non-space characters after ']', it's not a valid alert\n      if (currentPos < max) return false;\n\n      const oldBMarks: number[] = [];\n      const oldBSCount: number[] = [];\n      const oldSCount: number[] = [];\n      const oldTShift: number[] = [];\n      const oldLineMax = state.lineMax;\n      const oldParentType = state.parentType;\n      const terminatorRules = [\n        state.md.block.ruler.getRules(\"blockquote\"),\n        state.md.block.ruler.getRules(\"alert\"),\n      ].flat();\n\n      // @ts-expect-error: We are creating a new type called \"alert\"\n      state.parentType = \"alert\";\n\n      // Search the end of the block\n      //\n      // Block ends with either:\n      //  1. an empty line outside:\n      //     ```\n      //     > test\n      //\n      //     ```\n      //  2. an empty line inside:\n      //     ```\n      //     >\n      //     test\n      //     ```\n      //  3. another tag:\n      //     ```\n      //     > test\n      //      - - -\n      //     ```\n      let currentLine = startLine;\n      let lastLineEmpty = false;\n      let hasBodyContent = false;\n\n      for (; currentLine < endLine; currentLine++) {\n        // check if it's outdented, i.e. it's inside list item and indented\n        // less than said list item:\n        //\n        // ```\n        // 1. anything\n        //    > current blockquote\n        // 2. checking this line\n        // ```\n        const isOutdented = state.sCount[currentLine] < state.blkIndent;\n\n        let pos = state.bMarks[currentLine] + state.tShift[currentLine];\n        const max = state.eMarks[currentLine];\n\n        // Case 1: line is not inside the blockquote, and this line is empty.\n        if (pos >= max) break;\n\n        if (state.src.charCodeAt(pos++) === 62 /* > */ && !isOutdented) {\n          // This line is inside the blockquote.\n\n          // set offset past spaces and \">\"\n          let initial = state.sCount[currentLine] + 1;\n          let spaceAfterMarker = false;\n          let adjustTab = false;\n\n          // skip one optional space after '>'\n          if (state.src.charCodeAt(pos) === 32 /* space */) {\n            // ' >   test '\n            //     ^ -- position start of line here:\n            pos++;\n            initial++;\n            spaceAfterMarker = true;\n          } else if (state.src.charCodeAt(pos) === 9 /* \\t */) {\n            spaceAfterMarker = true;\n\n            if ((state.bsCount[currentLine] + initial) % 4 === 3) {\n              // '  >\\t  test '\n              //       ^ -- position start of line here (tab has width===1)\n              pos++;\n              initial++;\n            } else {\n              // ' >\\t  test '\n              //    ^ -- position start of line here + shift bsCount slightly\n              //         to make extra space appear\n              adjustTab = true;\n            }\n          }\n\n          let offset = initial;\n\n          if (!silent) {\n            oldBMarks.push(state.bMarks[currentLine]);\n            state.bMarks[currentLine] = pos;\n          }\n\n          while (pos < max) {\n            const ch = state.src.charCodeAt(pos);\n\n            if (ch === 9 /** \\t */)\n              offset += 4 - ((offset + state.bsCount[currentLine] + (adjustTab ? 1 : 0)) % 4);\n            else if (ch === 32 /** space */) offset++;\n            else break;\n\n            pos++;\n          }\n\n          lastLineEmpty = pos >= max;\n          if (currentLine > startLine && !lastLineEmpty) hasBodyContent = true;\n\n          if (!silent) {\n            oldBSCount.push(state.bsCount[currentLine]);\n            state.bsCount[currentLine] = state.sCount[currentLine] + 1 + (spaceAfterMarker ? 1 : 0);\n\n            oldSCount.push(state.sCount[currentLine]);\n            state.sCount[currentLine] = offset - initial;\n\n            oldTShift.push(state.tShift[currentLine]);\n            state.tShift[currentLine] = pos - state.bMarks[currentLine];\n          }\n          continue;\n        }\n\n        // Case 2: line is not inside the blockquote, and the last line was empty.\n        if (lastLineEmpty) break;\n\n        // Case 3: another tag found.\n        let terminate = false;\n\n        const terminateRuleLength = terminatorRules.length;\n\n        for (let i = 0; i < terminateRuleLength; i++) {\n          const terminatorRule = terminatorRules[i];\n\n          if (terminatorRule(state, currentLine, endLine, true)) {\n            terminate = true;\n            break;\n          }\n        }\n\n        if (terminate) {\n          // Quirk to enforce \"hard termination mode\" for paragraphs;\n          // normally if you call `tokenize(state, startLine, nextLine)`,\n          // paragraphs will look below nextLine for paragraph continuation,\n          // but if blockquote is terminated by another tag, they shouldn't\n          state.lineMax = currentLine;\n\n          if (state.blkIndent !== 0 && !silent) {\n            // state.blkIndent was non-zero, we now set it to zero,\n            // so we need to re-calculate all offsets to appear as\n            // if indent wasn't changed\n            oldBMarks.push(state.bMarks[currentLine]);\n            oldBSCount.push(state.bsCount[currentLine]);\n            oldSCount.push(state.sCount[currentLine]);\n            oldTShift.push(state.tShift[currentLine]);\n\n            state.sCount[currentLine] -= state.blkIndent;\n          }\n\n          break;\n        }\n\n        hasBodyContent = true;\n\n        if (!silent) {\n          oldBMarks.push(state.bMarks[currentLine]);\n          oldBSCount.push(state.bsCount[currentLine]);\n          oldSCount.push(state.sCount[currentLine]);\n          oldTShift.push(state.tShift[currentLine]);\n\n          // A negative indentation means that this is a paragraph continuation\n          // we only set it if it's not the first line of the body\n          if (currentLine > startLine + 1) state.sCount[currentLine] = -1;\n        }\n      }\n\n      const restoreState = (): void => {\n        state.lineMax = oldLineMax;\n        state.parentType = oldParentType;\n\n        // Restore original tShift; this might not be necessary since the parser\n        // has already been here, but just to make sure we can do that.\n        for (let i = 0; i < oldTShift.length; i++) {\n          state.bMarks[i + startLine] = oldBMarks[i];\n          state.tShift[i + startLine] = oldTShift[i];\n          state.sCount[i + startLine] = oldSCount[i];\n          state.bsCount[i + startLine] = oldBSCount[i];\n        }\n      };\n\n      // If we didn't find any alert body, so we don't have a valid alert\n      if (startLine + 1 >= currentLine || !hasBodyContent) {\n        // If we are in silent mode, we don't need to restore the state\n        if (!silent) restoreState();\n\n        return false;\n      }\n\n      // from now we know that it's going to be a valid alert,\n      // so no point trying to find the end of it in silent mode\n      if (silent) return true;\n\n      const oldIndent = state.blkIndent;\n\n      state.blkIndent = 0;\n\n      const titleLines: [number, number] = [startLine, startLine + 1];\n      const contentLines: [number, number] = [startLine + 1, 0];\n\n      const openToken = state.push(\"alert_open\", \"div\", 1);\n\n      openToken.markup = type;\n      openToken.attrJoin(\"class\", `markdown-alert markdown-alert-${type}`);\n      openToken.map = contentLines;\n\n      const titleToken = state.push(\"alert_title\", \"\", 0);\n\n      titleToken.attrJoin(\"class\", `markdown-alert-title`);\n      titleToken.markup = type;\n      titleToken.content = typeName;\n      titleToken.map = titleLines;\n\n      state.md.block.tokenize(state, startLine + 1, currentLine);\n\n      const closeToken = state.push(\"alert_close\", \"div\", -1);\n\n      closeToken.markup = type;\n      contentLines[1] = state.line;\n\n      state.blkIndent = oldIndent;\n      restoreState();\n\n      return true;\n    };\n\nexport const alert: PluginWithOptions<MarkdownItAlertOptions> = (\n  md,\n  {\n    alertNames = [\"tip\", \"warning\", \"caution\", \"important\", \"note\"],\n    deep = false,\n    openRender,\n    closeRender,\n    titleRender,\n  } = {},\n) => {\n  md.block.ruler.before(\n    \"blockquote\",\n    \"alert\",\n    getAlertRule(new Set(alertNames.map((name) => name.toLowerCase())), deep),\n    {\n      alt: [\"paragraph\", \"reference\", \"blockquote\", \"list\"],\n    },\n  );\n\n  if (openRender) md.renderer.rules.alert_open = openRender;\n\n  if (closeRender) md.renderer.rules.alert_close = closeRender;\n\n  md.renderer.rules.alert_title =\n    titleRender ??\n    ((tokens, index): string => {\n      const token = tokens[index];\n\n      return `<p class=\"markdown-alert-title\">${\n        token.content[0].toUpperCase() + token.content.slice(1).toLowerCase()\n      }</p>\\n`;\n    });\n};\n"],"mappings":"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"}
