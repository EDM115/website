diff --git a/CHANGELOG.md b/CHANGELOG.md
deleted file mode 100644
index 225addd6a0aa4a842c61644000b0775383119a11..0000000000000000000000000000000000000000
diff --git a/dist/markdownItTocDoneRight.js b/dist/markdownItTocDoneRight.js
index acb45efbc1c0d5164628fe4fb8e55d0b8e634d0c..c750c159cdcb703dd90593a3a0893b04d952aa00 100644
--- a/dist/markdownItTocDoneRight.js
+++ b/dist/markdownItTocDoneRight.js
@@ -1,2 +1,2 @@
-function e(e){return encodeURIComponent(String(e).trim().toLowerCase().replace(/\s+/g,"-"))}function n(e){return String(e).replace(/&/g,"&amp;").replace(/"/g,"&quot;").replace(/'/g,"&#39;").replace(/</g,"&lt;").replace(/>/g,"&gt;")}module.exports=function(r,t){var l;t=Object.assign({},{placeholder:"(\\$\\{toc\\}|\\[\\[?_?toc_?\\]?\\]|\\$\\<toc(\\{[^}]*\\})\\>)",slugify:e,uniqueSlugStartIndex:1,containerClass:"table-of-contents",containerId:void 0,listClass:void 0,itemClass:void 0,linkClass:void 0,level:1,listType:"ol",format:void 0,callback:void 0},t);var i=new RegExp("^"+t.placeholder+"$","i");r.renderer.rules.tocOpen=function(e,r){var l=Object.assign({},t);return e&&r>=0&&(l=Object.assign(l,e[r].inlineOptions)),"<nav"+(l.containerId?' id="'+n(l.containerId)+'"':"")+' class="'+n(l.containerClass)+'">'},r.renderer.rules.tocClose=function(){return"</nav>"},r.renderer.rules.tocBody=function(e,r){var i=Object.assign({},t);e&&r>=0&&(i=Object.assign(i,e[r].inlineOptions));var s,a={},c=Array.isArray(i.level)?(s=i.level,function(e){return s.includes(e)}):function(e){return function(n){return n>=e}}(i.level);return function e(r){var l=i.listClass?' class="'+n(i.listClass)+'"':"",s=i.itemClass?' class="'+n(i.itemClass)+'"':"",o=i.linkClass?' class="'+n(i.linkClass)+'"':"";if(0===r.c.length)return"";var u="";return(0===r.l||c(r.l))&&(u+="<"+(n(i.listType)+l)+">"),r.c.forEach(function(r){c(r.l)?u+="<li"+s+"><a"+o+' href="#'+function(e){for(var n=e,r=i.uniqueSlugStartIndex;Object.prototype.hasOwnProperty.call(a,n);)n=e+"-"+r++;return a[n]=!0,n}(t.slugify(r.n))+'">'+("function"==typeof i.format?i.format(r.n,n):n(r.n))+"</a>"+e(r)+"</li>":u+=e(r)}),(0===r.l||c(r.l))&&(u+="</"+n(i.listType)+">"),u}(l)},r.core.ruler.push("generateTocAst",function(e){l=function(e){for(var n={l:0,n:"",c:[]},r=[n],t=0,l=e.length;t<l;t++){var i=e[t];if("heading_open"===i.type){var s=e[t+1].children.filter(function(e){return"text"===e.type||"code_inline"===e.type}).reduce(function(e,n){return e+n.content},""),a={l:parseInt(i.tag.substr(1),10),n:s,c:[]};if(a.l>r[0].l)r[0].c.push(a),r.unshift(a);else if(a.l===r[0].l)r[1].c.push(a),r[0]=a;else{for(;a.l<=r[0].l;)r.shift();r[0].c.push(a),r.unshift(a)}}}return n}(e.tokens),"function"==typeof t.callback&&t.callback(r.renderer.rules.tocOpen()+r.renderer.rules.tocBody()+r.renderer.rules.tocClose(),l)}),r.block.ruler.before("heading","toc",function(e,n,r,t){var l,s=e.src.slice(e.bMarks[n]+e.tShift[n],e.eMarks[n]).split(" ")[0];if(!i.test(s))return!1;if(t)return!0;var a=i.exec(s),c={};if(null!==a&&3===a.length)try{c=JSON.parse(a[2])}catch(e){}return e.line=n+1,(l=e.push("tocOpen","nav",1)).markup="",l.map=[n,e.line],l.inlineOptions=c,(l=e.push("tocBody","",0)).markup="",l.map=[n,e.line],l.inlineOptions=c,l.children=[],(l=e.push("tocClose","nav",-1)).markup="",!0},{alt:["paragraph","reference","blockquote"]})};
+function e(e){return encodeURIComponent(String(e).trim().toLowerCase().replace(/\s+/g,"-"))}function n(e){return String(e).replace(/&/g,"&amp;").replace(/"/g,"&quot;").replace(/'/g,"&#39;").replace(/</g,"&lt;").replace(/>/g,"&gt;")}module.exports=function(r,t){var l;t=Object.assign({},{placeholder:"(\\$\\{toc\\}|\\[\\[?_?toc_?\\]?\\]|\\$\\<toc(\\{[^}]*\\})\\>)",slugify:e,uniqueSlugStartIndex:1,containerClass:"table-of-contents",containerId:void 0,listClass:void 0,itemClass:void 0,linkClass:void 0,level:1,listType:"ol",format:void 0,callback:void 0},t);var i=new RegExp("^"+t.placeholder+"$","i");r.renderer.rules.tocOpen=function(e,r){var l=Object.assign({},t);return e&&r>=0&&(l=Object.assign(l,e[r].inlineOptions)),"<nav"+(l.containerId?' id="'+n(l.containerId)+'"':"")+' class="'+n(l.containerClass)+'">'},r.renderer.rules.tocClose=function(){return"</nav>"},r.renderer.rules.tocBody=function(e,r){var i=Object.assign({},t);e&&r>=0&&(i=Object.assign(i,e[r].inlineOptions));var s,a={},o=Array.isArray(i.level)?(s=i.level,function(e){return s.includes(e)}):function(e){return function(n){return n>=e}}(i.level);return function e(r){var l=i.listClass?' class="'+n(i.listClass)+'"':"",s=i.itemClass?' class="'+n(i.itemClass)+'"':"",c=i.linkClass?' class="'+n(i.linkClass)+'"':"";if(0===r.c.length)return"";var u="";return(0===r.l||o(r.l))&&(u+="<"+(n(i.listType)+l)+">"),r.c.forEach(function(r){o(r.l)?u+="<li"+s+"><a"+c+' href="#'+function(e){for(var n=e,r=i.uniqueSlugStartIndex;Object.prototype.hasOwnProperty.call(a,n);)n=e+"-"+r++;return a[n]=!0,n}(t.slugify(r.n))+'">'+("function"==typeof i.format?i.format(r.n,n):n(r.n))+"</a>"+e(r)+"</li>":u+=e(r)}),(0===r.l||o(r.l))&&(u+="</"+n(i.listType)+">"),u}(l)},r.core.ruler.push("generateTocAst",function(e){l=function(e){for(var n={l:0,n:"",c:[]},r=[n],t=0,l=e.length;t<l;t++){var i=e[t];if("heading_open"===i.type){var s=e[t+1].children.filter(function(e){return"text"===e.type||"code_inline"===e.type||"emoji"===e.type}).reduce(function(e,n){return e+n.content},""),a={l:parseInt(i.tag.substr(1),10),n:s,c:[]};if(a.l>r[0].l)r[0].c.push(a),r.unshift(a);else if(a.l===r[0].l)r[1].c.push(a),r[0]=a;else{for(;a.l<=r[0].l;)r.shift();r[0].c.push(a),r.unshift(a)}}}return n}(e.tokens),"function"==typeof t.callback&&t.callback(r.renderer.rules.tocOpen()+r.renderer.rules.tocBody()+r.renderer.rules.tocClose(),l)}),r.block.ruler.before("heading","toc",function(e,n,r,t){var l,s=e.src.slice(e.bMarks[n]+e.tShift[n],e.eMarks[n]).split(" ")[0];if(!i.test(s))return!1;if(t)return!0;var a=i.exec(s),o={};if(null!==a&&3===a.length)try{o=JSON.parse(a[2])}catch(e){}return e.line=n+1,(l=e.push("tocOpen","nav",1)).markup="",l.map=[n,e.line],l.inlineOptions=o,(l=e.push("tocBody","",0)).markup="",l.map=[n,e.line],l.inlineOptions=o,l.children=[],(l=e.push("tocClose","nav",-1)).markup="",!0},{alt:["paragraph","reference","blockquote"]})};
 //# sourceMappingURL=markdownItTocDoneRight.js.map
diff --git a/dist/markdownItTocDoneRight.js.map b/dist/markdownItTocDoneRight.js.map
index 496d115cf3f54f1776a9b404d649ad581b410f8b..4ae5432685bfdad48aaf494ee3e828688e709cab 100644
--- a/dist/markdownItTocDoneRight.js.map
+++ b/dist/markdownItTocDoneRight.js.map
@@ -1 +1 @@
-{"version":3,"file":"markdownItTocDoneRight.js","sources":["../index.js"],"sourcesContent":["'use strict'\n\nfunction slugify (x) {\n  return encodeURIComponent(String(x).trim().toLowerCase().replace(/\\s+/g, '-'))\n}\n\nfunction htmlencode (x) {\n/*\n  // safest, delegate task to native -- IMPORTANT: enabling this breaks both jest and runkit, but with browserify it's fine\n  if (document && document.createElement) {\n    const el = document.createElement(\"div\")\n    el.innerText = x\n    return el.innerHTML\n  }\n*/\n\n  return String(x)\n    .replace(/&/g, '&amp;')\n    .replace(/\"/g, '&quot;')\n    .replace(/'/g, '&#39;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n}\n\nfunction tocPlugin (md, options) {\n  options = Object.assign({}, {\n    placeholder: '(\\\\$\\\\{toc\\\\}|\\\\[\\\\[?_?toc_?\\\\]?\\\\]|\\\\$\\\\<toc(\\\\{[^}]*\\\\})\\\\>)',\n    slugify: slugify,\n    uniqueSlugStartIndex: 1,\n    containerClass: 'table-of-contents',\n    containerId: undefined,\n    listClass: undefined,\n    itemClass: undefined,\n    linkClass: undefined,\n    level: 1,\n    listType: 'ol',\n    format: undefined,\n    callback: undefined/* function(html, ast) {} */\n  }, options)\n\n  let ast\n  const pattern = new RegExp('^' + options.placeholder + '$', 'i')\n\n  function toc (state, startLine, endLine, silent) {\n    let token\n    const pos = state.bMarks[startLine] + state.tShift[startLine]\n    const max = state.eMarks[startLine]\n\n    // use whitespace as a line tokenizer and extract the first token\n    // to test against the placeholder anchored pattern, rejecting if false\n    const lineFirstToken = state.src.slice(pos, max).split(' ')[0]\n    if (!pattern.test(lineFirstToken)) return false\n\n    if (silent) return true\n\n    const matches = pattern.exec(lineFirstToken)\n    let inlineOptions = {}\n    if (matches !== null && matches.length === 3) {\n      try {\n        inlineOptions = JSON.parse(matches[2])\n      } catch (ex) {\n        // silently ignore inline options\n      }\n    }\n\n    state.line = startLine + 1\n\n    token = state.push('tocOpen', 'nav', 1)\n    token.markup = ''\n    token.map = [startLine, state.line]\n    token.inlineOptions = inlineOptions\n\n    token = state.push('tocBody', '', 0)\n    token.markup = ''\n    token.map = [startLine, state.line]\n    token.inlineOptions = inlineOptions\n    token.children = []\n\n    token = state.push('tocClose', 'nav', -1)\n    token.markup = ''\n\n    return true\n  }\n\n  md.renderer.rules.tocOpen = function (tokens, idx/* , options, env, renderer */) {\n    let _options = Object.assign({}, options)\n    if (tokens && idx >= 0) {\n      const token = tokens[idx]\n      _options = Object.assign(_options, token.inlineOptions)\n    }\n    const id = _options.containerId ? ` id=\"${htmlencode(_options.containerId)}\"` : ''\n    return `<nav${id} class=\"${htmlencode(_options.containerClass)}\">`\n  }\n\n  md.renderer.rules.tocClose = function (/* tokens, idx, options, env, renderer */) {\n    return '</nav>'\n  }\n\n  md.renderer.rules.tocBody = function (tokens, idx/* , options, env, renderer */) {\n    let _options = Object.assign({}, options)\n    if (tokens && idx >= 0) {\n      const token = tokens[idx]\n      _options = Object.assign(_options, token.inlineOptions)\n    }\n\n    const uniques = {}\n    function unique (s) {\n      let u = s\n      let i = _options.uniqueSlugStartIndex\n      while (Object.prototype.hasOwnProperty.call(uniques, u)) u = `${s}-${i++}`\n      uniques[u] = true\n      return u\n    }\n\n    const isLevelSelectedNumber = selection => level => level >= selection\n    const isLevelSelectedArray = selection => level => selection.includes(level)\n\n    const isLevelSelected = Array.isArray(_options.level)\n      ? isLevelSelectedArray(_options.level)\n      : isLevelSelectedNumber(_options.level)\n\n    function ast2html (tree) {\n      const listClass = _options.listClass ? ` class=\"${htmlencode(_options.listClass)}\"` : ''\n      const itemClass = _options.itemClass ? ` class=\"${htmlencode(_options.itemClass)}\"` : ''\n      const linkClass = _options.linkClass ? ` class=\"${htmlencode(_options.linkClass)}\"` : ''\n\n      if (tree.c.length === 0) return ''\n\n      let buffer = ''\n      if (tree.l === 0 || isLevelSelected(tree.l)) {\n        buffer += (`<${htmlencode(_options.listType) + listClass}>`)\n      }\n      tree.c.forEach(node => {\n        if (isLevelSelected(node.l)) {\n          buffer += (`<li${itemClass}><a${linkClass} href=\"#${unique(options.slugify(node.n))}\">${typeof _options.format === 'function' ? _options.format(node.n, htmlencode) : htmlencode(node.n)}</a>${ast2html(node)}</li>`)\n        } else {\n          buffer += ast2html(node)\n        }\n      })\n      if (tree.l === 0 || isLevelSelected(tree.l)) {\n        buffer += (`</${htmlencode(_options.listType)}>`)\n      }\n      return buffer\n    }\n\n    return ast2html(ast)\n  }\n\n  function headings2ast (tokens) {\n    const ast = { l: 0, n: '', c: [] }\n    const stack = [ast]\n\n    for (let i = 0, iK = tokens.length; i < iK; i++) {\n      const token = tokens[i]\n      if (token.type === 'heading_open') {\n        const key = (\n          tokens[i + 1]\n            .children\n            .filter(function (token) { return token.type === 'text' || token.type === 'code_inline' })\n            .reduce(function (s, t) { return s + t.content }, '')\n        )\n\n        const node = {\n          l: parseInt(token.tag.substr(1), 10),\n          n: key,\n          c: []\n        }\n\n        if (node.l > stack[0].l) {\n          stack[0].c.push(node)\n          stack.unshift(node)\n        } else if (node.l === stack[0].l) {\n          stack[1].c.push(node)\n          stack[0] = node\n        } else {\n          while (node.l <= stack[0].l) stack.shift()\n          stack[0].c.push(node)\n          stack.unshift(node)\n        }\n      }\n    }\n\n    return ast\n  }\n\n  md.core.ruler.push('generateTocAst', function (state) {\n    const tokens = state.tokens\n    ast = headings2ast(tokens)\n\n    if (typeof options.callback === 'function') {\n      options.callback(\n        md.renderer.rules.tocOpen() + md.renderer.rules.tocBody() + md.renderer.rules.tocClose(),\n        ast\n      )\n    }\n  })\n\n  md.block.ruler.before('heading', 'toc', toc, {\n    alt: ['paragraph', 'reference', 'blockquote']\n  })\n}\n\nexport default tocPlugin\n"],"names":["slugify","x","encodeURIComponent","String","trim","toLowerCase","replace","htmlencode","md","options","ast","Object","assign","placeholder","uniqueSlugStartIndex","containerClass","containerId","undefined","listClass","itemClass","linkClass","level","listType","format","callback","pattern","RegExp","renderer","rules","tocOpen","tokens","idx","_options","inlineOptions","tocClose","tocBody","selection","uniques","isLevelSelected","Array","isArray","includes","isLevelSelectedNumber","ast2html","tree","c","length","buffer","l","forEach","node","s","u","i","prototype","hasOwnProperty","call","unique","n","core","ruler","push","state","stack","iK","token","type","key","children","filter","reduce","t","content","parseInt","tag","substr","unshift","shift","headings2ast","block","before","startLine","endLine","silent","lineFirstToken","src","slice","bMarks","tShift","eMarks","split","test","matches","exec","JSON","parse","ex","line","markup","map","alt"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"markdownItTocDoneRight.js","sources":["../index.js"],"sourcesContent":["'use strict'\n\nfunction slugify (x) {\n  return encodeURIComponent(String(x).trim().toLowerCase().replace(/\\s+/g, '-'))\n}\n\nfunction htmlencode (x) {\n/*\n  // safest, delegate task to native -- IMPORTANT: enabling this breaks both jest and runkit, but with browserify it's fine\n  if (document && document.createElement) {\n    const el = document.createElement(\"div\")\n    el.innerText = x\n    return el.innerHTML\n  }\n*/\n\n  return String(x)\n    .replace(/&/g, '&amp;')\n    .replace(/\"/g, '&quot;')\n    .replace(/'/g, '&#39;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n}\n\nfunction tocPlugin (md, options) {\n  options = Object.assign({}, {\n    placeholder: '(\\\\$\\\\{toc\\\\}|\\\\[\\\\[?_?toc_?\\\\]?\\\\]|\\\\$\\\\<toc(\\\\{[^}]*\\\\})\\\\>)',\n    slugify: slugify,\n    uniqueSlugStartIndex: 1,\n    containerClass: 'table-of-contents',\n    containerId: undefined,\n    listClass: undefined,\n    itemClass: undefined,\n    linkClass: undefined,\n    level: 1,\n    listType: 'ol',\n    format: undefined,\n    callback: undefined/* function(html, ast) {} */\n  }, options)\n\n  let ast\n  const pattern = new RegExp('^' + options.placeholder + '$', 'i')\n\n  function toc (state, startLine, endLine, silent) {\n    let token\n    const pos = state.bMarks[startLine] + state.tShift[startLine]\n    const max = state.eMarks[startLine]\n\n    // use whitespace as a line tokenizer and extract the first token\n    // to test against the placeholder anchored pattern, rejecting if false\n    const lineFirstToken = state.src.slice(pos, max).split(' ')[0]\n    if (!pattern.test(lineFirstToken)) return false\n\n    if (silent) return true\n\n    const matches = pattern.exec(lineFirstToken)\n    let inlineOptions = {}\n    if (matches !== null && matches.length === 3) {\n      try {\n        inlineOptions = JSON.parse(matches[2])\n      } catch (ex) {\n        // silently ignore inline options\n      }\n    }\n\n    state.line = startLine + 1\n\n    token = state.push('tocOpen', 'nav', 1)\n    token.markup = ''\n    token.map = [startLine, state.line]\n    token.inlineOptions = inlineOptions\n\n    token = state.push('tocBody', '', 0)\n    token.markup = ''\n    token.map = [startLine, state.line]\n    token.inlineOptions = inlineOptions\n    token.children = []\n\n    token = state.push('tocClose', 'nav', -1)\n    token.markup = ''\n\n    return true\n  }\n\n  md.renderer.rules.tocOpen = function (tokens, idx/* , options, env, renderer */) {\n    let _options = Object.assign({}, options)\n    if (tokens && idx >= 0) {\n      const token = tokens[idx]\n      _options = Object.assign(_options, token.inlineOptions)\n    }\n    const id = _options.containerId ? ` id=\"${htmlencode(_options.containerId)}\"` : ''\n    return `<nav${id} class=\"${htmlencode(_options.containerClass)}\">`\n  }\n\n  md.renderer.rules.tocClose = function (/* tokens, idx, options, env, renderer */) {\n    return '</nav>'\n  }\n\n  md.renderer.rules.tocBody = function (tokens, idx/* , options, env, renderer */) {\n    let _options = Object.assign({}, options)\n    if (tokens && idx >= 0) {\n      const token = tokens[idx]\n      _options = Object.assign(_options, token.inlineOptions)\n    }\n\n    const uniques = {}\n    function unique (s) {\n      let u = s\n      let i = _options.uniqueSlugStartIndex\n      while (Object.prototype.hasOwnProperty.call(uniques, u)) u = `${s}-${i++}`\n      uniques[u] = true\n      return u\n    }\n\n    const isLevelSelectedNumber = selection => level => level >= selection\n    const isLevelSelectedArray = selection => level => selection.includes(level)\n\n    const isLevelSelected = Array.isArray(_options.level)\n      ? isLevelSelectedArray(_options.level)\n      : isLevelSelectedNumber(_options.level)\n\n    function ast2html (tree) {\n      const listClass = _options.listClass ? ` class=\"${htmlencode(_options.listClass)}\"` : ''\n      const itemClass = _options.itemClass ? ` class=\"${htmlencode(_options.itemClass)}\"` : ''\n      const linkClass = _options.linkClass ? ` class=\"${htmlencode(_options.linkClass)}\"` : ''\n\n      if (tree.c.length === 0) return ''\n\n      let buffer = ''\n      if (tree.l === 0 || isLevelSelected(tree.l)) {\n        buffer += (`<${htmlencode(_options.listType) + listClass}>`)\n      }\n      tree.c.forEach(node => {\n        if (isLevelSelected(node.l)) {\n          buffer += (`<li${itemClass}><a${linkClass} href=\"#${unique(options.slugify(node.n))}\">${typeof _options.format === 'function' ? _options.format(node.n, htmlencode) : htmlencode(node.n)}</a>${ast2html(node)}</li>`)\n        } else {\n          buffer += ast2html(node)\n        }\n      })\n      if (tree.l === 0 || isLevelSelected(tree.l)) {\n        buffer += (`</${htmlencode(_options.listType)}>`)\n      }\n      return buffer\n    }\n\n    return ast2html(ast)\n  }\n\n  function headings2ast (tokens) {\n    const ast = { l: 0, n: '', c: [] }\n    const stack = [ast]\n\n    for (let i = 0, iK = tokens.length; i < iK; i++) {\n      const token = tokens[i]\n      if (token.type === 'heading_open') {\n        const key = (\n          tokens[i + 1]\n            .children\n            .filter(function (token) { return token.type === 'text' || token.type === 'code_inline' || token.type === 'emoji' })\n            .reduce(function (s, t) { return s + t.content }, '')\n        )\n\n        const node = {\n          l: parseInt(token.tag.substr(1), 10),\n          n: key,\n          c: []\n        }\n\n        if (node.l > stack[0].l) {\n          stack[0].c.push(node)\n          stack.unshift(node)\n        } else if (node.l === stack[0].l) {\n          stack[1].c.push(node)\n          stack[0] = node\n        } else {\n          while (node.l <= stack[0].l) stack.shift()\n          stack[0].c.push(node)\n          stack.unshift(node)\n        }\n      }\n    }\n\n    return ast\n  }\n\n  md.core.ruler.push('generateTocAst', function (state) {\n    const tokens = state.tokens\n    ast = headings2ast(tokens)\n\n    if (typeof options.callback === 'function') {\n      options.callback(\n        md.renderer.rules.tocOpen() + md.renderer.rules.tocBody() + md.renderer.rules.tocClose(),\n        ast\n      )\n    }\n  })\n\n  md.block.ruler.before('heading', 'toc', toc, {\n    alt: ['paragraph', 'reference', 'blockquote']\n  })\n}\n\nexport default tocPlugin\n"],"names":["slugify","x","encodeURIComponent","String","trim","toLowerCase","replace","htmlencode","md","options","ast","Object","assign","placeholder","uniqueSlugStartIndex","containerClass","containerId","undefined","listClass","itemClass","linkClass","level","listType","format","callback","pattern","RegExp","renderer","rules","tocOpen","tokens","idx","_options","inlineOptions","tocClose","tocBody","selection","uniques","isLevelSelected","Array","isArray","includes","isLevelSelectedNumber","ast2html","tree","c","length","buffer","l","forEach","node","s","u","i","prototype","hasOwnProperty","call","unique","n","core","ruler","push","state","stack","iK","token","type","key","children","filter","reduce","t","content","parseInt","tag","substr","unshift","shift","headings2ast","block","before","startLine","endLine","silent","lineFirstToken","src","slice","bMarks","tShift","eMarks","split","test","matches","exec","JSON","parse","ex","line","markup","map","alt"],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/markdownItTocDoneRight.mjs b/dist/markdownItTocDoneRight.mjs
index 039c5821132456ea22b2d7b8bbe5dac1f20f8049..cc525c117703e324aacde3aabe4f9a31f4bdf01c 100644
--- a/dist/markdownItTocDoneRight.mjs
+++ b/dist/markdownItTocDoneRight.mjs
@@ -1,2 +1,2 @@
-function e(e){return encodeURIComponent(String(e).trim().toLowerCase().replace(/\s+/g,"-"))}function n(e){return String(e).replace(/&/g,"&amp;").replace(/"/g,"&quot;").replace(/'/g,"&#39;").replace(/</g,"&lt;").replace(/>/g,"&gt;")}export default function(r,t){var l;t=Object.assign({},{placeholder:"(\\$\\{toc\\}|\\[\\[?_?toc_?\\]?\\]|\\$\\<toc(\\{[^}]*\\})\\>)",slugify:e,uniqueSlugStartIndex:1,containerClass:"table-of-contents",containerId:void 0,listClass:void 0,itemClass:void 0,linkClass:void 0,level:1,listType:"ol",format:void 0,callback:void 0},t);var i=new RegExp("^"+t.placeholder+"$","i");r.renderer.rules.tocOpen=function(e,r){var l=Object.assign({},t);return e&&r>=0&&(l=Object.assign(l,e[r].inlineOptions)),"<nav"+(l.containerId?' id="'+n(l.containerId)+'"':"")+' class="'+n(l.containerClass)+'">'},r.renderer.rules.tocClose=function(){return"</nav>"},r.renderer.rules.tocBody=function(e,r){var i=Object.assign({},t);e&&r>=0&&(i=Object.assign(i,e[r].inlineOptions));var s,a={},c=Array.isArray(i.level)?(s=i.level,function(e){return s.includes(e)}):function(e){return function(n){return n>=e}}(i.level);return function e(r){var l=i.listClass?' class="'+n(i.listClass)+'"':"",s=i.itemClass?' class="'+n(i.itemClass)+'"':"",o=i.linkClass?' class="'+n(i.linkClass)+'"':"";if(0===r.c.length)return"";var u="";return(0===r.l||c(r.l))&&(u+="<"+(n(i.listType)+l)+">"),r.c.forEach(function(r){c(r.l)?u+="<li"+s+"><a"+o+' href="#'+function(e){for(var n=e,r=i.uniqueSlugStartIndex;Object.prototype.hasOwnProperty.call(a,n);)n=e+"-"+r++;return a[n]=!0,n}(t.slugify(r.n))+'">'+("function"==typeof i.format?i.format(r.n,n):n(r.n))+"</a>"+e(r)+"</li>":u+=e(r)}),(0===r.l||c(r.l))&&(u+="</"+n(i.listType)+">"),u}(l)},r.core.ruler.push("generateTocAst",function(e){l=function(e){for(var n={l:0,n:"",c:[]},r=[n],t=0,l=e.length;t<l;t++){var i=e[t];if("heading_open"===i.type){var s=e[t+1].children.filter(function(e){return"text"===e.type||"code_inline"===e.type}).reduce(function(e,n){return e+n.content},""),a={l:parseInt(i.tag.substr(1),10),n:s,c:[]};if(a.l>r[0].l)r[0].c.push(a),r.unshift(a);else if(a.l===r[0].l)r[1].c.push(a),r[0]=a;else{for(;a.l<=r[0].l;)r.shift();r[0].c.push(a),r.unshift(a)}}}return n}(e.tokens),"function"==typeof t.callback&&t.callback(r.renderer.rules.tocOpen()+r.renderer.rules.tocBody()+r.renderer.rules.tocClose(),l)}),r.block.ruler.before("heading","toc",function(e,n,r,t){var l,s=e.src.slice(e.bMarks[n]+e.tShift[n],e.eMarks[n]).split(" ")[0];if(!i.test(s))return!1;if(t)return!0;var a=i.exec(s),c={};if(null!==a&&3===a.length)try{c=JSON.parse(a[2])}catch(e){}return e.line=n+1,(l=e.push("tocOpen","nav",1)).markup="",l.map=[n,e.line],l.inlineOptions=c,(l=e.push("tocBody","",0)).markup="",l.map=[n,e.line],l.inlineOptions=c,l.children=[],(l=e.push("tocClose","nav",-1)).markup="",!0},{alt:["paragraph","reference","blockquote"]})}
+function e(e){return encodeURIComponent(String(e).trim().toLowerCase().replace(/\s+/g,"-"))}function n(e){return String(e).replace(/&/g,"&amp;").replace(/"/g,"&quot;").replace(/'/g,"&#39;").replace(/</g,"&lt;").replace(/>/g,"&gt;")}export default function(r,t){var l;t=Object.assign({},{placeholder:"(\\$\\{toc\\}|\\[\\[?_?toc_?\\]?\\]|\\$\\<toc(\\{[^}]*\\})\\>)",slugify:e,uniqueSlugStartIndex:1,containerClass:"table-of-contents",containerId:void 0,listClass:void 0,itemClass:void 0,linkClass:void 0,level:1,listType:"ol",format:void 0,callback:void 0},t);var i=new RegExp("^"+t.placeholder+"$","i");r.renderer.rules.tocOpen=function(e,r){var l=Object.assign({},t);return e&&r>=0&&(l=Object.assign(l,e[r].inlineOptions)),"<nav"+(l.containerId?' id="'+n(l.containerId)+'"':"")+' class="'+n(l.containerClass)+'">'},r.renderer.rules.tocClose=function(){return"</nav>"},r.renderer.rules.tocBody=function(e,r){var i=Object.assign({},t);e&&r>=0&&(i=Object.assign(i,e[r].inlineOptions));var s,a={},c=Array.isArray(i.level)?(s=i.level,function(e){return s.includes(e)}):function(e){return function(n){return n>=e}}(i.level);return function e(r){var l=i.listClass?' class="'+n(i.listClass)+'"':"",s=i.itemClass?' class="'+n(i.itemClass)+'"':"",o=i.linkClass?' class="'+n(i.linkClass)+'"':"";if(0===r.c.length)return"";var u="";return(0===r.l||c(r.l))&&(u+="<"+(n(i.listType)+l)+">"),r.c.forEach(function(r){c(r.l)?u+="<li"+s+"><a"+o+' href="#'+function(e){for(var n=e,r=i.uniqueSlugStartIndex;Object.prototype.hasOwnProperty.call(a,n);)n=e+"-"+r++;return a[n]=!0,n}(t.slugify(r.n))+'">'+("function"==typeof i.format?i.format(r.n,n):n(r.n))+"</a>"+e(r)+"</li>":u+=e(r)}),(0===r.l||c(r.l))&&(u+="</"+n(i.listType)+">"),u}(l)},r.core.ruler.push("generateTocAst",function(e){l=function(e){for(var n={l:0,n:"",c:[]},r=[n],t=0,l=e.length;t<l;t++){var i=e[t];if("heading_open"===i.type){var s=e[t+1].children.filter(function(e){return"text"===e.type||"code_inline"===e.type||"emoji"===e.type}).reduce(function(e,n){return e+n.content},""),a={l:parseInt(i.tag.substr(1),10),n:s,c:[]};if(a.l>r[0].l)r[0].c.push(a),r.unshift(a);else if(a.l===r[0].l)r[1].c.push(a),r[0]=a;else{for(;a.l<=r[0].l;)r.shift();r[0].c.push(a),r.unshift(a)}}}return n}(e.tokens),"function"==typeof t.callback&&t.callback(r.renderer.rules.tocOpen()+r.renderer.rules.tocBody()+r.renderer.rules.tocClose(),l)}),r.block.ruler.before("heading","toc",function(e,n,r,t){var l,s=e.src.slice(e.bMarks[n]+e.tShift[n],e.eMarks[n]).split(" ")[0];if(!i.test(s))return!1;if(t)return!0;var a=i.exec(s),c={};if(null!==a&&3===a.length)try{c=JSON.parse(a[2])}catch(e){}return e.line=n+1,(l=e.push("tocOpen","nav",1)).markup="",l.map=[n,e.line],l.inlineOptions=c,(l=e.push("tocBody","",0)).markup="",l.map=[n,e.line],l.inlineOptions=c,l.children=[],(l=e.push("tocClose","nav",-1)).markup="",!0},{alt:["paragraph","reference","blockquote"]})}
 //# sourceMappingURL=markdownItTocDoneRight.mjs.map
diff --git a/dist/markdownItTocDoneRight.mjs.map b/dist/markdownItTocDoneRight.mjs.map
index 3045b7ea473be9bb95874ff3cdd9ed9ee915c174..5b32be78dfc8c01679370af12271f86507559541 100644
--- a/dist/markdownItTocDoneRight.mjs.map
+++ b/dist/markdownItTocDoneRight.mjs.map
@@ -1 +1 @@
-{"version":3,"file":"markdownItTocDoneRight.mjs","sources":["../index.js"],"sourcesContent":["'use strict'\n\nfunction slugify (x) {\n  return encodeURIComponent(String(x).trim().toLowerCase().replace(/\\s+/g, '-'))\n}\n\nfunction htmlencode (x) {\n/*\n  // safest, delegate task to native -- IMPORTANT: enabling this breaks both jest and runkit, but with browserify it's fine\n  if (document && document.createElement) {\n    const el = document.createElement(\"div\")\n    el.innerText = x\n    return el.innerHTML\n  }\n*/\n\n  return String(x)\n    .replace(/&/g, '&amp;')\n    .replace(/\"/g, '&quot;')\n    .replace(/'/g, '&#39;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n}\n\nfunction tocPlugin (md, options) {\n  options = Object.assign({}, {\n    placeholder: '(\\\\$\\\\{toc\\\\}|\\\\[\\\\[?_?toc_?\\\\]?\\\\]|\\\\$\\\\<toc(\\\\{[^}]*\\\\})\\\\>)',\n    slugify: slugify,\n    uniqueSlugStartIndex: 1,\n    containerClass: 'table-of-contents',\n    containerId: undefined,\n    listClass: undefined,\n    itemClass: undefined,\n    linkClass: undefined,\n    level: 1,\n    listType: 'ol',\n    format: undefined,\n    callback: undefined/* function(html, ast) {} */\n  }, options)\n\n  let ast\n  const pattern = new RegExp('^' + options.placeholder + '$', 'i')\n\n  function toc (state, startLine, endLine, silent) {\n    let token\n    const pos = state.bMarks[startLine] + state.tShift[startLine]\n    const max = state.eMarks[startLine]\n\n    // use whitespace as a line tokenizer and extract the first token\n    // to test against the placeholder anchored pattern, rejecting if false\n    const lineFirstToken = state.src.slice(pos, max).split(' ')[0]\n    if (!pattern.test(lineFirstToken)) return false\n\n    if (silent) return true\n\n    const matches = pattern.exec(lineFirstToken)\n    let inlineOptions = {}\n    if (matches !== null && matches.length === 3) {\n      try {\n        inlineOptions = JSON.parse(matches[2])\n      } catch (ex) {\n        // silently ignore inline options\n      }\n    }\n\n    state.line = startLine + 1\n\n    token = state.push('tocOpen', 'nav', 1)\n    token.markup = ''\n    token.map = [startLine, state.line]\n    token.inlineOptions = inlineOptions\n\n    token = state.push('tocBody', '', 0)\n    token.markup = ''\n    token.map = [startLine, state.line]\n    token.inlineOptions = inlineOptions\n    token.children = []\n\n    token = state.push('tocClose', 'nav', -1)\n    token.markup = ''\n\n    return true\n  }\n\n  md.renderer.rules.tocOpen = function (tokens, idx/* , options, env, renderer */) {\n    let _options = Object.assign({}, options)\n    if (tokens && idx >= 0) {\n      const token = tokens[idx]\n      _options = Object.assign(_options, token.inlineOptions)\n    }\n    const id = _options.containerId ? ` id=\"${htmlencode(_options.containerId)}\"` : ''\n    return `<nav${id} class=\"${htmlencode(_options.containerClass)}\">`\n  }\n\n  md.renderer.rules.tocClose = function (/* tokens, idx, options, env, renderer */) {\n    return '</nav>'\n  }\n\n  md.renderer.rules.tocBody = function (tokens, idx/* , options, env, renderer */) {\n    let _options = Object.assign({}, options)\n    if (tokens && idx >= 0) {\n      const token = tokens[idx]\n      _options = Object.assign(_options, token.inlineOptions)\n    }\n\n    const uniques = {}\n    function unique (s) {\n      let u = s\n      let i = _options.uniqueSlugStartIndex\n      while (Object.prototype.hasOwnProperty.call(uniques, u)) u = `${s}-${i++}`\n      uniques[u] = true\n      return u\n    }\n\n    const isLevelSelectedNumber = selection => level => level >= selection\n    const isLevelSelectedArray = selection => level => selection.includes(level)\n\n    const isLevelSelected = Array.isArray(_options.level)\n      ? isLevelSelectedArray(_options.level)\n      : isLevelSelectedNumber(_options.level)\n\n    function ast2html (tree) {\n      const listClass = _options.listClass ? ` class=\"${htmlencode(_options.listClass)}\"` : ''\n      const itemClass = _options.itemClass ? ` class=\"${htmlencode(_options.itemClass)}\"` : ''\n      const linkClass = _options.linkClass ? ` class=\"${htmlencode(_options.linkClass)}\"` : ''\n\n      if (tree.c.length === 0) return ''\n\n      let buffer = ''\n      if (tree.l === 0 || isLevelSelected(tree.l)) {\n        buffer += (`<${htmlencode(_options.listType) + listClass}>`)\n      }\n      tree.c.forEach(node => {\n        if (isLevelSelected(node.l)) {\n          buffer += (`<li${itemClass}><a${linkClass} href=\"#${unique(options.slugify(node.n))}\">${typeof _options.format === 'function' ? _options.format(node.n, htmlencode) : htmlencode(node.n)}</a>${ast2html(node)}</li>`)\n        } else {\n          buffer += ast2html(node)\n        }\n      })\n      if (tree.l === 0 || isLevelSelected(tree.l)) {\n        buffer += (`</${htmlencode(_options.listType)}>`)\n      }\n      return buffer\n    }\n\n    return ast2html(ast)\n  }\n\n  function headings2ast (tokens) {\n    const ast = { l: 0, n: '', c: [] }\n    const stack = [ast]\n\n    for (let i = 0, iK = tokens.length; i < iK; i++) {\n      const token = tokens[i]\n      if (token.type === 'heading_open') {\n        const key = (\n          tokens[i + 1]\n            .children\n            .filter(function (token) { return token.type === 'text' || token.type === 'code_inline' })\n            .reduce(function (s, t) { return s + t.content }, '')\n        )\n\n        const node = {\n          l: parseInt(token.tag.substr(1), 10),\n          n: key,\n          c: []\n        }\n\n        if (node.l > stack[0].l) {\n          stack[0].c.push(node)\n          stack.unshift(node)\n        } else if (node.l === stack[0].l) {\n          stack[1].c.push(node)\n          stack[0] = node\n        } else {\n          while (node.l <= stack[0].l) stack.shift()\n          stack[0].c.push(node)\n          stack.unshift(node)\n        }\n      }\n    }\n\n    return ast\n  }\n\n  md.core.ruler.push('generateTocAst', function (state) {\n    const tokens = state.tokens\n    ast = headings2ast(tokens)\n\n    if (typeof options.callback === 'function') {\n      options.callback(\n        md.renderer.rules.tocOpen() + md.renderer.rules.tocBody() + md.renderer.rules.tocClose(),\n        ast\n      )\n    }\n  })\n\n  md.block.ruler.before('heading', 'toc', toc, {\n    alt: ['paragraph', 'reference', 'blockquote']\n  })\n}\n\nexport default tocPlugin\n"],"names":["slugify","x","encodeURIComponent","String","trim","toLowerCase","replace","htmlencode","md","options","ast","Object","assign","placeholder","uniqueSlugStartIndex","containerClass","containerId","undefined","listClass","itemClass","linkClass","level","listType","format","callback","pattern","RegExp","renderer","rules","tocOpen","tokens","idx","_options","inlineOptions","tocClose","tocBody","selection","uniques","isLevelSelected","Array","isArray","includes","isLevelSelectedNumber","ast2html","tree","c","length","buffer","l","forEach","node","s","u","i","prototype","hasOwnProperty","call","unique","n","core","ruler","push","state","stack","iK","token","type","key","children","filter","reduce","t","content","parseInt","tag","substr","unshift","shift","headings2ast","block","before","startLine","endLine","silent","lineFirstToken","src","slice","bMarks","tShift","eMarks","split","test","matches","exec","JSON","parse","ex","line","markup","map","alt"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"markdownItTocDoneRight.mjs","sources":["../index.js"],"sourcesContent":["'use strict'\n\nfunction slugify (x) {\n  return encodeURIComponent(String(x).trim().toLowerCase().replace(/\\s+/g, '-'))\n}\n\nfunction htmlencode (x) {\n/*\n  // safest, delegate task to native -- IMPORTANT: enabling this breaks both jest and runkit, but with browserify it's fine\n  if (document && document.createElement) {\n    const el = document.createElement(\"div\")\n    el.innerText = x\n    return el.innerHTML\n  }\n*/\n\n  return String(x)\n    .replace(/&/g, '&amp;')\n    .replace(/\"/g, '&quot;')\n    .replace(/'/g, '&#39;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n}\n\nfunction tocPlugin (md, options) {\n  options = Object.assign({}, {\n    placeholder: '(\\\\$\\\\{toc\\\\}|\\\\[\\\\[?_?toc_?\\\\]?\\\\]|\\\\$\\\\<toc(\\\\{[^}]*\\\\})\\\\>)',\n    slugify: slugify,\n    uniqueSlugStartIndex: 1,\n    containerClass: 'table-of-contents',\n    containerId: undefined,\n    listClass: undefined,\n    itemClass: undefined,\n    linkClass: undefined,\n    level: 1,\n    listType: 'ol',\n    format: undefined,\n    callback: undefined/* function(html, ast) {} */\n  }, options)\n\n  let ast\n  const pattern = new RegExp('^' + options.placeholder + '$', 'i')\n\n  function toc (state, startLine, endLine, silent) {\n    let token\n    const pos = state.bMarks[startLine] + state.tShift[startLine]\n    const max = state.eMarks[startLine]\n\n    // use whitespace as a line tokenizer and extract the first token\n    // to test against the placeholder anchored pattern, rejecting if false\n    const lineFirstToken = state.src.slice(pos, max).split(' ')[0]\n    if (!pattern.test(lineFirstToken)) return false\n\n    if (silent) return true\n\n    const matches = pattern.exec(lineFirstToken)\n    let inlineOptions = {}\n    if (matches !== null && matches.length === 3) {\n      try {\n        inlineOptions = JSON.parse(matches[2])\n      } catch (ex) {\n        // silently ignore inline options\n      }\n    }\n\n    state.line = startLine + 1\n\n    token = state.push('tocOpen', 'nav', 1)\n    token.markup = ''\n    token.map = [startLine, state.line]\n    token.inlineOptions = inlineOptions\n\n    token = state.push('tocBody', '', 0)\n    token.markup = ''\n    token.map = [startLine, state.line]\n    token.inlineOptions = inlineOptions\n    token.children = []\n\n    token = state.push('tocClose', 'nav', -1)\n    token.markup = ''\n\n    return true\n  }\n\n  md.renderer.rules.tocOpen = function (tokens, idx/* , options, env, renderer */) {\n    let _options = Object.assign({}, options)\n    if (tokens && idx >= 0) {\n      const token = tokens[idx]\n      _options = Object.assign(_options, token.inlineOptions)\n    }\n    const id = _options.containerId ? ` id=\"${htmlencode(_options.containerId)}\"` : ''\n    return `<nav${id} class=\"${htmlencode(_options.containerClass)}\">`\n  }\n\n  md.renderer.rules.tocClose = function (/* tokens, idx, options, env, renderer */) {\n    return '</nav>'\n  }\n\n  md.renderer.rules.tocBody = function (tokens, idx/* , options, env, renderer */) {\n    let _options = Object.assign({}, options)\n    if (tokens && idx >= 0) {\n      const token = tokens[idx]\n      _options = Object.assign(_options, token.inlineOptions)\n    }\n\n    const uniques = {}\n    function unique (s) {\n      let u = s\n      let i = _options.uniqueSlugStartIndex\n      while (Object.prototype.hasOwnProperty.call(uniques, u)) u = `${s}-${i++}`\n      uniques[u] = true\n      return u\n    }\n\n    const isLevelSelectedNumber = selection => level => level >= selection\n    const isLevelSelectedArray = selection => level => selection.includes(level)\n\n    const isLevelSelected = Array.isArray(_options.level)\n      ? isLevelSelectedArray(_options.level)\n      : isLevelSelectedNumber(_options.level)\n\n    function ast2html (tree) {\n      const listClass = _options.listClass ? ` class=\"${htmlencode(_options.listClass)}\"` : ''\n      const itemClass = _options.itemClass ? ` class=\"${htmlencode(_options.itemClass)}\"` : ''\n      const linkClass = _options.linkClass ? ` class=\"${htmlencode(_options.linkClass)}\"` : ''\n\n      if (tree.c.length === 0) return ''\n\n      let buffer = ''\n      if (tree.l === 0 || isLevelSelected(tree.l)) {\n        buffer += (`<${htmlencode(_options.listType) + listClass}>`)\n      }\n      tree.c.forEach(node => {\n        if (isLevelSelected(node.l)) {\n          buffer += (`<li${itemClass}><a${linkClass} href=\"#${unique(options.slugify(node.n))}\">${typeof _options.format === 'function' ? _options.format(node.n, htmlencode) : htmlencode(node.n)}</a>${ast2html(node)}</li>`)\n        } else {\n          buffer += ast2html(node)\n        }\n      })\n      if (tree.l === 0 || isLevelSelected(tree.l)) {\n        buffer += (`</${htmlencode(_options.listType)}>`)\n      }\n      return buffer\n    }\n\n    return ast2html(ast)\n  }\n\n  function headings2ast (tokens) {\n    const ast = { l: 0, n: '', c: [] }\n    const stack = [ast]\n\n    for (let i = 0, iK = tokens.length; i < iK; i++) {\n      const token = tokens[i]\n      if (token.type === 'heading_open') {\n        const key = (\n          tokens[i + 1]\n            .children\n            .filter(function (token) { return token.type === 'text' || token.type === 'code_inline' || token.type === 'emoji' })\n            .reduce(function (s, t) { return s + t.content }, '')\n        )\n\n        const node = {\n          l: parseInt(token.tag.substr(1), 10),\n          n: key,\n          c: []\n        }\n\n        if (node.l > stack[0].l) {\n          stack[0].c.push(node)\n          stack.unshift(node)\n        } else if (node.l === stack[0].l) {\n          stack[1].c.push(node)\n          stack[0] = node\n        } else {\n          while (node.l <= stack[0].l) stack.shift()\n          stack[0].c.push(node)\n          stack.unshift(node)\n        }\n      }\n    }\n\n    return ast\n  }\n\n  md.core.ruler.push('generateTocAst', function (state) {\n    const tokens = state.tokens\n    ast = headings2ast(tokens)\n\n    if (typeof options.callback === 'function') {\n      options.callback(\n        md.renderer.rules.tocOpen() + md.renderer.rules.tocBody() + md.renderer.rules.tocClose(),\n        ast\n      )\n    }\n  })\n\n  md.block.ruler.before('heading', 'toc', toc, {\n    alt: ['paragraph', 'reference', 'blockquote']\n  })\n}\n\nexport default tocPlugin\n"],"names":["slugify","x","encodeURIComponent","String","trim","toLowerCase","replace","htmlencode","md","options","ast","Object","assign","placeholder","uniqueSlugStartIndex","containerClass","containerId","undefined","listClass","itemClass","linkClass","level","listType","format","callback","pattern","RegExp","renderer","rules","tocOpen","tokens","idx","_options","inlineOptions","tocClose","tocBody","selection","uniques","isLevelSelected","Array","isArray","includes","isLevelSelectedNumber","ast2html","tree","c","length","buffer","l","forEach","node","s","u","i","prototype","hasOwnProperty","call","unique","n","core","ruler","push","state","stack","iK","token","type","key","children","filter","reduce","t","content","parseInt","tag","substr","unshift","shift","headings2ast","block","before","startLine","endLine","silent","lineFirstToken","src","slice","bMarks","tShift","eMarks","split","test","matches","exec","JSON","parse","ex","line","markup","map","alt"],"mappings":"AAEA,SAASA,EAASC,GAChB,OAAOC,mBAAmBC,OAAOF,GAAGG,OAAOC,cAAcC,QAAQ,OAAQ,MAG3E,SAASC,EAAYN,GAUnB,OAAOE,OAAOF,GACXK,QAAQ,KAAM,SACdA,QAAQ,KAAM,UACdA,QAAQ,KAAM,SACdA,QAAQ,KAAM,QACdA,QAAQ,KAAM,uBAGnB,SAAoBE,EAAIC,GAgBtB,IAAIC,EAfJD,EAAUE,OAAOC,OAAO,GAAI,CAC1BC,YAAa,iEACbb,QAASA,EACTc,qBAAsB,EACtBC,eAAgB,oBAChBC,iBAAaC,EACbC,eAAWD,EACXE,eAAWF,EACXG,eAAWH,EACXI,MAAO,EACPC,SAAU,KACVC,YAAQN,EACRO,cAAUP,GACTR,GAGH,IAAMgB,EAAU,IAAIC,OAAO,IAAMjB,EAAQI,YAAc,IAAK,KA2C5DL,EAAGmB,SAASC,MAAMC,QAAU,SAAUC,EAAQC,GAC5C,IAAIC,EAAWrB,OAAOC,OAAO,GAAIH,GAMjC,OALIqB,GAAUC,GAAO,IAEnBC,EAAWrB,OAAOC,OAAOoB,EADXF,EAAOC,GACoBE,wBAEhCD,EAAShB,oBAAsBT,EAAWyB,EAAShB,iBAAkB,eACrDT,EAAWyB,EAASjB,sBAGjDP,EAAGmB,SAASC,MAAMM,SAAW,WAC3B,MAAO,UAGT1B,EAAGmB,SAASC,MAAMO,QAAU,SAAUL,EAAQC,GAC5C,IAAIC,EAAWrB,OAAOC,OAAO,GAAIH,GAC7BqB,GAAUC,GAAO,IAEnBC,EAAWrB,OAAOC,OAAOoB,EADXF,EAAOC,GACoBE,gBAG3C,IAU6BG,EAVvBC,EAAU,GAYVC,EAAkBC,MAAMC,QAAQR,EAASX,QAFlBe,EAGJJ,EAASX,eAHQA,UAASe,EAAUK,SAASpB,KADxC,SAAAe,mBAAaf,UAASA,GAASe,GAKzDM,CAAsBV,EAASX,OA0BnC,OAxBA,SAASsB,EAAUC,GACjB,IAAM1B,EAAYc,EAASd,qBAAuBX,EAAWyB,EAASd,eAAgB,GAChFC,EAAYa,EAASb,qBAAuBZ,EAAWyB,EAASb,eAAgB,GAChFC,EAAYY,EAASZ,qBAAuBb,EAAWyB,EAASZ,eAAgB,GAEtF,GAAsB,IAAlBwB,EAAKC,EAAEC,OAAc,MAAO,GAEhC,IAAIC,EAAS,GAcb,OAbe,IAAXH,EAAKI,GAAWV,EAAgBM,EAAKI,MACvCD,QAAexC,EAAWyB,EAASV,UAAYJ,QAEjD0B,EAAKC,EAAEI,QAAQ,SAAAC,GACTZ,EAAgBY,EAAKF,GACvBD,SAAiB5B,QAAeC,aA5BtC,SAAiB+B,GAGf,IAFA,IAAIC,EAAID,EACJE,EAAIrB,EAASlB,qBACVH,OAAO2C,UAAUC,eAAeC,KAAKnB,EAASe,IAAIA,EAAOD,MAAKE,IAErE,OADAhB,EAAQe,IAAK,EACNA,EAuBiDK,CAAOhD,EAAQT,QAAQkD,EAAKQ,UAAmC,mBAApB1B,EAAST,OAAwBS,EAAST,OAAO2B,EAAKQ,EAAGnD,GAAcA,EAAW2C,EAAKQ,WAASf,EAASO,WAExMH,GAAUJ,EAASO,MAGR,IAAXN,EAAKI,GAAWV,EAAgBM,EAAKI,MACvCD,QAAgBxC,EAAWyB,EAASV,eAE/ByB,EAGFJ,CAASjC,IAwClBF,EAAGmD,KAAKC,MAAMC,KAAK,iBAAkB,SAAUC,GAE7CpD,EAvCF,SAAuBoB,GAIrB,IAHA,IAAMpB,EAAM,CAAEsC,EAAG,EAAGU,EAAG,GAAIb,EAAG,IACxBkB,EAAQ,CAACrD,GAEN2C,EAAI,EAAGW,EAAKlC,EAAOgB,OAAQO,EAAIW,EAAIX,IAAK,CAC/C,IAAMY,EAAQnC,EAAOuB,GACrB,GAAmB,iBAAfY,EAAMC,KAAyB,CACjC,IAAMC,EACJrC,EAAOuB,EAAI,GACRe,SACAC,OAAO,SAAUJ,GAAS,MAAsB,SAAfA,EAAMC,MAAkC,gBAAfD,EAAMC,MAAyC,UAAfD,EAAMC,OAChGI,OAAO,SAAUnB,EAAGoB,GAAK,OAAOpB,EAAIoB,EAAEC,SAAW,IAGhDtB,EAAO,CACXF,EAAGyB,SAASR,EAAMS,IAAIC,OAAO,GAAI,IACjCjB,EAAGS,EACHtB,EAAG,IAGL,GAAIK,EAAKF,EAAIe,EAAM,GAAGf,EACpBe,EAAM,GAAGlB,EAAEgB,KAAKX,GAChBa,EAAMa,QAAQ1B,WACLA,EAAKF,IAAMe,EAAM,GAAGf,EAC7Be,EAAM,GAAGlB,EAAEgB,KAAKX,GAChBa,EAAM,GAAKb,MACN,CACL,KAAOA,EAAKF,GAAKe,EAAM,GAAGf,GAAGe,EAAMc,QACnCd,EAAM,GAAGlB,EAAEgB,KAAKX,GAChBa,EAAMa,QAAQ1B,KAKpB,OAAOxC,EAKDoE,CADShB,EAAMhC,QAGW,mBAArBrB,EAAQe,UACjBf,EAAQe,SACNhB,EAAGmB,SAASC,MAAMC,UAAYrB,EAAGmB,SAASC,MAAMO,UAAY3B,EAAGmB,SAASC,MAAMM,WAC9ExB,KAKNF,EAAGuE,MAAMnB,MAAMoB,OAAO,UAAW,MA1JjC,SAAclB,EAAOmB,EAAWC,EAASC,GACvC,IAAIlB,EAMEmB,EAAiBtB,EAAMuB,IAAIC,MALrBxB,EAAMyB,OAAON,GAAanB,EAAM0B,OAAOP,GACvCnB,EAAM2B,OAAOR,IAIwBS,MAAM,KAAK,GAC5D,IAAKjE,EAAQkE,KAAKP,GAAiB,SAEnC,GAAID,EAAQ,SAEZ,IAAMS,EAAUnE,EAAQoE,KAAKT,GACzBnD,EAAgB,GACpB,GAAgB,OAAZ2D,GAAuC,IAAnBA,EAAQ9C,OAC9B,IACEb,EAAgB6D,KAAKC,MAAMH,EAAQ,IACnC,MAAOI,IAqBX,OAhBAlC,EAAMmC,KAAOhB,EAAY,GAEzBhB,EAAQH,EAAMD,KAAK,UAAW,MAAO,IAC/BqC,OAAS,GACfjC,EAAMkC,IAAM,CAAClB,EAAWnB,EAAMmC,MAC9BhC,EAAMhC,cAAgBA,GAEtBgC,EAAQH,EAAMD,KAAK,UAAW,GAAI,IAC5BqC,OAAS,GACfjC,EAAMkC,IAAM,CAAClB,EAAWnB,EAAMmC,MAC9BhC,EAAMhC,cAAgBA,EACtBgC,EAAMG,SAAW,IAEjBH,EAAQH,EAAMD,KAAK,WAAY,OAAQ,IACjCqC,OAAS,OAsH4B,CAC3CE,IAAK,CAAC,YAAa,YAAa"}
\ No newline at end of file
diff --git a/dist/markdownItTocDoneRight.modern.js b/dist/markdownItTocDoneRight.modern.js
index 46817a90b76878fa0a6f05f76bc61a3600eb4786..dcc6fddd582c62481070a2915041b6507b9eaad4 100644
--- a/dist/markdownItTocDoneRight.modern.js
+++ b/dist/markdownItTocDoneRight.modern.js
@@ -1,2 +1,2 @@
-function e(e){return encodeURIComponent(String(e).trim().toLowerCase().replace(/\s+/g,"-"))}function n(e){return String(e).replace(/&/g,"&amp;").replace(/"/g,"&quot;").replace(/'/g,"&#39;").replace(/</g,"&lt;").replace(/>/g,"&gt;")}export default function(t,l){let r;l=Object.assign({},{placeholder:"(\\$\\{toc\\}|\\[\\[?_?toc_?\\]?\\]|\\$\\<toc(\\{[^}]*\\})\\>)",slugify:e,uniqueSlugStartIndex:1,containerClass:"table-of-contents",containerId:void 0,listClass:void 0,itemClass:void 0,linkClass:void 0,level:1,listType:"ol",format:void 0,callback:void 0},l);const s=new RegExp("^"+l.placeholder+"$","i");t.renderer.rules.tocOpen=function(e,t){let r=Object.assign({},l);return e&&t>=0&&(r=Object.assign(r,e[t].inlineOptions)),`<nav${r.containerId?` id="${n(r.containerId)}"`:""} class="${n(r.containerClass)}">`},t.renderer.rules.tocClose=function(){return"</nav>"},t.renderer.rules.tocBody=function(e,t){let s=Object.assign({},l);e&&t>=0&&(s=Object.assign(s,e[t].inlineOptions));const c={},i=Array.isArray(s.level)?(o=s.level,e=>o.includes(e)):(e=>n=>n>=e)(s.level);var o;return function e(t){const r=s.listClass?` class="${n(s.listClass)}"`:"",o=s.itemClass?` class="${n(s.itemClass)}"`:"",a=s.linkClass?` class="${n(s.linkClass)}"`:"";if(0===t.c.length)return"";let u="";return(0===t.l||i(t.l))&&(u+=`<${n(s.listType)+r}>`),t.c.forEach(t=>{i(t.l)?u+=`<li${o}><a${a} href="#${function(e){let n=e,t=s.uniqueSlugStartIndex;for(;Object.prototype.hasOwnProperty.call(c,n);)n=`${e}-${t++}`;return c[n]=!0,n}(l.slugify(t.n))}">${"function"==typeof s.format?s.format(t.n,n):n(t.n)}</a>${e(t)}</li>`:u+=e(t)}),(0===t.l||i(t.l))&&(u+=`</${n(s.listType)}>`),u}(r)},t.core.ruler.push("generateTocAst",function(e){r=function(e){const n={l:0,n:"",c:[]},t=[n];for(let n=0,l=e.length;n<l;n++){const l=e[n];if("heading_open"===l.type){const r=e[n+1].children.filter(function(e){return"text"===e.type||"code_inline"===e.type}).reduce(function(e,n){return e+n.content},""),s={l:parseInt(l.tag.substr(1),10),n:r,c:[]};if(s.l>t[0].l)t[0].c.push(s),t.unshift(s);else if(s.l===t[0].l)t[1].c.push(s),t[0]=s;else{for(;s.l<=t[0].l;)t.shift();t[0].c.push(s),t.unshift(s)}}}return n}(e.tokens),"function"==typeof l.callback&&l.callback(t.renderer.rules.tocOpen()+t.renderer.rules.tocBody()+t.renderer.rules.tocClose(),r)}),t.block.ruler.before("heading","toc",function(e,n,t,l){let r;const c=e.src.slice(e.bMarks[n]+e.tShift[n],e.eMarks[n]).split(" ")[0];if(!s.test(c))return!1;if(l)return!0;const i=s.exec(c);let o={};if(null!==i&&3===i.length)try{o=JSON.parse(i[2])}catch(e){}return e.line=n+1,r=e.push("tocOpen","nav",1),r.markup="",r.map=[n,e.line],r.inlineOptions=o,r=e.push("tocBody","",0),r.markup="",r.map=[n,e.line],r.inlineOptions=o,r.children=[],r=e.push("tocClose","nav",-1),r.markup="",!0},{alt:["paragraph","reference","blockquote"]})}
+function e(e){return encodeURIComponent(String(e).trim().toLowerCase().replace(/\s+/g,"-"))}function t(e){return String(e).replace(/&/g,"&amp;").replace(/"/g,"&quot;").replace(/'/g,"&#39;").replace(/</g,"&lt;").replace(/>/g,"&gt;")}export default function(n,l){let r;l=Object.assign({},{placeholder:"(\\$\\{toc\\}|\\[\\[?_?toc_?\\]?\\]|\\$\\<toc(\\{[^}]*\\})\\>)",slugify:e,uniqueSlugStartIndex:1,containerClass:"table-of-contents",containerId:void 0,listClass:void 0,itemClass:void 0,linkClass:void 0,level:1,listType:"ol",format:void 0,callback:void 0},l);const s=new RegExp("^"+l.placeholder+"$","i");n.renderer.rules.tocOpen=function(e,n){let r=Object.assign({},l);return e&&n>=0&&(r=Object.assign(r,e[n].inlineOptions)),`<nav${r.containerId?` id="${t(r.containerId)}"`:""} class="${t(r.containerClass)}">`},n.renderer.rules.tocClose=function(){return"</nav>"},n.renderer.rules.tocBody=function(e,n){let s=Object.assign({},l);e&&n>=0&&(s=Object.assign(s,e[n].inlineOptions));const c={},i=Array.isArray(s.level)?(o=s.level,e=>o.includes(e)):(e=>t=>t>=e)(s.level);var o;return function e(n){const r=s.listClass?` class="${t(s.listClass)}"`:"",o=s.itemClass?` class="${t(s.itemClass)}"`:"",a=s.linkClass?` class="${t(s.linkClass)}"`:"";if(0===n.c.length)return"";let u="";return(0===n.l||i(n.l))&&(u+=`<${t(s.listType)+r}>`),n.c.forEach(n=>{i(n.l)?u+=`<li${o}><a${a} href="#${function(e){let t=e,n=s.uniqueSlugStartIndex;for(;Object.prototype.hasOwnProperty.call(c,t);)t=`${e}-${n++}`;return c[t]=!0,t}(l.slugify(n.n))}">${"function"==typeof s.format?s.format(n.n,t):t(n.n)}</a>${e(n)}</li>`:u+=e(n)}),(0===n.l||i(n.l))&&(u+=`</${t(s.listType)}>`),u}(r)},n.core.ruler.push("generateTocAst",function(e){r=function(e){const t={l:0,n:"",c:[]},n=[t];for(let t=0,l=e.length;t<l;t++){const l=e[t];if("heading_open"===l.type){const r=e[t+1].children.filter(function(e){return"text"===e.type||"code_inline"===e.type||"emoji"===e.type}).reduce(function(e,t){return e+t.content},""),s={l:parseInt(l.tag.substr(1),10),n:r,c:[]};if(s.l>n[0].l)n[0].c.push(s),n.unshift(s);else if(s.l===n[0].l)n[1].c.push(s),n[0]=s;else{for(;s.l<=n[0].l;)n.shift();n[0].c.push(s),n.unshift(s)}}}return t}(e.tokens),"function"==typeof l.callback&&l.callback(n.renderer.rules.tocOpen()+n.renderer.rules.tocBody()+n.renderer.rules.tocClose(),r)}),n.block.ruler.before("heading","toc",function(e,t,n,l){let r;const c=e.src.slice(e.bMarks[t]+e.tShift[t],e.eMarks[t]).split(" ")[0];if(!s.test(c))return!1;if(l)return!0;const i=s.exec(c);let o={};if(null!==i&&3===i.length)try{o=JSON.parse(i[2])}catch(e){}return e.line=t+1,r=e.push("tocOpen","nav",1),r.markup="",r.map=[t,e.line],r.inlineOptions=o,r=e.push("tocBody","",0),r.markup="",r.map=[t,e.line],r.inlineOptions=o,r.children=[],r=e.push("tocClose","nav",-1),r.markup="",!0},{alt:["paragraph","reference","blockquote"]})}
 //# sourceMappingURL=markdownItTocDoneRight.modern.js.map
diff --git a/dist/markdownItTocDoneRight.modern.js.map b/dist/markdownItTocDoneRight.modern.js.map
index 10744be822e5353c8ee685d77b8c1e15b859705b..8264c75893c5e9b168ff5cc92945516240436231 100644
--- a/dist/markdownItTocDoneRight.modern.js.map
+++ b/dist/markdownItTocDoneRight.modern.js.map
@@ -1 +1 @@
-{"version":3,"file":"markdownItTocDoneRight.modern.js","sources":["../index.js"],"sourcesContent":["'use strict'\n\nfunction slugify (x) {\n  return encodeURIComponent(String(x).trim().toLowerCase().replace(/\\s+/g, '-'))\n}\n\nfunction htmlencode (x) {\n/*\n  // safest, delegate task to native -- IMPORTANT: enabling this breaks both jest and runkit, but with browserify it's fine\n  if (document && document.createElement) {\n    const el = document.createElement(\"div\")\n    el.innerText = x\n    return el.innerHTML\n  }\n*/\n\n  return String(x)\n    .replace(/&/g, '&amp;')\n    .replace(/\"/g, '&quot;')\n    .replace(/'/g, '&#39;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n}\n\nfunction tocPlugin (md, options) {\n  options = Object.assign({}, {\n    placeholder: '(\\\\$\\\\{toc\\\\}|\\\\[\\\\[?_?toc_?\\\\]?\\\\]|\\\\$\\\\<toc(\\\\{[^}]*\\\\})\\\\>)',\n    slugify: slugify,\n    uniqueSlugStartIndex: 1,\n    containerClass: 'table-of-contents',\n    containerId: undefined,\n    listClass: undefined,\n    itemClass: undefined,\n    linkClass: undefined,\n    level: 1,\n    listType: 'ol',\n    format: undefined,\n    callback: undefined/* function(html, ast) {} */\n  }, options)\n\n  let ast\n  const pattern = new RegExp('^' + options.placeholder + '$', 'i')\n\n  function toc (state, startLine, endLine, silent) {\n    let token\n    const pos = state.bMarks[startLine] + state.tShift[startLine]\n    const max = state.eMarks[startLine]\n\n    // use whitespace as a line tokenizer and extract the first token\n    // to test against the placeholder anchored pattern, rejecting if false\n    const lineFirstToken = state.src.slice(pos, max).split(' ')[0]\n    if (!pattern.test(lineFirstToken)) return false\n\n    if (silent) return true\n\n    const matches = pattern.exec(lineFirstToken)\n    let inlineOptions = {}\n    if (matches !== null && matches.length === 3) {\n      try {\n        inlineOptions = JSON.parse(matches[2])\n      } catch (ex) {\n        // silently ignore inline options\n      }\n    }\n\n    state.line = startLine + 1\n\n    token = state.push('tocOpen', 'nav', 1)\n    token.markup = ''\n    token.map = [startLine, state.line]\n    token.inlineOptions = inlineOptions\n\n    token = state.push('tocBody', '', 0)\n    token.markup = ''\n    token.map = [startLine, state.line]\n    token.inlineOptions = inlineOptions\n    token.children = []\n\n    token = state.push('tocClose', 'nav', -1)\n    token.markup = ''\n\n    return true\n  }\n\n  md.renderer.rules.tocOpen = function (tokens, idx/* , options, env, renderer */) {\n    let _options = Object.assign({}, options)\n    if (tokens && idx >= 0) {\n      const token = tokens[idx]\n      _options = Object.assign(_options, token.inlineOptions)\n    }\n    const id = _options.containerId ? ` id=\"${htmlencode(_options.containerId)}\"` : ''\n    return `<nav${id} class=\"${htmlencode(_options.containerClass)}\">`\n  }\n\n  md.renderer.rules.tocClose = function (/* tokens, idx, options, env, renderer */) {\n    return '</nav>'\n  }\n\n  md.renderer.rules.tocBody = function (tokens, idx/* , options, env, renderer */) {\n    let _options = Object.assign({}, options)\n    if (tokens && idx >= 0) {\n      const token = tokens[idx]\n      _options = Object.assign(_options, token.inlineOptions)\n    }\n\n    const uniques = {}\n    function unique (s) {\n      let u = s\n      let i = _options.uniqueSlugStartIndex\n      while (Object.prototype.hasOwnProperty.call(uniques, u)) u = `${s}-${i++}`\n      uniques[u] = true\n      return u\n    }\n\n    const isLevelSelectedNumber = selection => level => level >= selection\n    const isLevelSelectedArray = selection => level => selection.includes(level)\n\n    const isLevelSelected = Array.isArray(_options.level)\n      ? isLevelSelectedArray(_options.level)\n      : isLevelSelectedNumber(_options.level)\n\n    function ast2html (tree) {\n      const listClass = _options.listClass ? ` class=\"${htmlencode(_options.listClass)}\"` : ''\n      const itemClass = _options.itemClass ? ` class=\"${htmlencode(_options.itemClass)}\"` : ''\n      const linkClass = _options.linkClass ? ` class=\"${htmlencode(_options.linkClass)}\"` : ''\n\n      if (tree.c.length === 0) return ''\n\n      let buffer = ''\n      if (tree.l === 0 || isLevelSelected(tree.l)) {\n        buffer += (`<${htmlencode(_options.listType) + listClass}>`)\n      }\n      tree.c.forEach(node => {\n        if (isLevelSelected(node.l)) {\n          buffer += (`<li${itemClass}><a${linkClass} href=\"#${unique(options.slugify(node.n))}\">${typeof _options.format === 'function' ? _options.format(node.n, htmlencode) : htmlencode(node.n)}</a>${ast2html(node)}</li>`)\n        } else {\n          buffer += ast2html(node)\n        }\n      })\n      if (tree.l === 0 || isLevelSelected(tree.l)) {\n        buffer += (`</${htmlencode(_options.listType)}>`)\n      }\n      return buffer\n    }\n\n    return ast2html(ast)\n  }\n\n  function headings2ast (tokens) {\n    const ast = { l: 0, n: '', c: [] }\n    const stack = [ast]\n\n    for (let i = 0, iK = tokens.length; i < iK; i++) {\n      const token = tokens[i]\n      if (token.type === 'heading_open') {\n        const key = (\n          tokens[i + 1]\n            .children\n            .filter(function (token) { return token.type === 'text' || token.type === 'code_inline' })\n            .reduce(function (s, t) { return s + t.content }, '')\n        )\n\n        const node = {\n          l: parseInt(token.tag.substr(1), 10),\n          n: key,\n          c: []\n        }\n\n        if (node.l > stack[0].l) {\n          stack[0].c.push(node)\n          stack.unshift(node)\n        } else if (node.l === stack[0].l) {\n          stack[1].c.push(node)\n          stack[0] = node\n        } else {\n          while (node.l <= stack[0].l) stack.shift()\n          stack[0].c.push(node)\n          stack.unshift(node)\n        }\n      }\n    }\n\n    return ast\n  }\n\n  md.core.ruler.push('generateTocAst', function (state) {\n    const tokens = state.tokens\n    ast = headings2ast(tokens)\n\n    if (typeof options.callback === 'function') {\n      options.callback(\n        md.renderer.rules.tocOpen() + md.renderer.rules.tocBody() + md.renderer.rules.tocClose(),\n        ast\n      )\n    }\n  })\n\n  md.block.ruler.before('heading', 'toc', toc, {\n    alt: ['paragraph', 'reference', 'blockquote']\n  })\n}\n\nexport default tocPlugin\n"],"names":["slugify","x","encodeURIComponent","String","trim","toLowerCase","replace","htmlencode","md","options","ast","Object","assign","placeholder","uniqueSlugStartIndex","containerClass","containerId","undefined","listClass","itemClass","linkClass","level","listType","format","callback","pattern","RegExp","renderer","rules","tocOpen","tokens","idx","_options","inlineOptions","tocClose","tocBody","uniques","isLevelSelected","Array","isArray","selection","includes","isLevelSelectedNumber","ast2html","tree","c","length","buffer","l","forEach","node","s","u","i","prototype","hasOwnProperty","call","unique","n","core","ruler","push","state","stack","iK","token","type","key","children","filter","reduce","t","content","parseInt","tag","substr","unshift","shift","headings2ast","block","before","startLine","endLine","silent","lineFirstToken","src","slice","bMarks","tShift","eMarks","split","test","matches","exec","JSON","parse","ex","line","markup","map","alt"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"markdownItTocDoneRight.modern.js","sources":["../index.js"],"sourcesContent":["'use strict'\n\nfunction slugify (x) {\n  return encodeURIComponent(String(x).trim().toLowerCase().replace(/\\s+/g, '-'))\n}\n\nfunction htmlencode (x) {\n/*\n  // safest, delegate task to native -- IMPORTANT: enabling this breaks both jest and runkit, but with browserify it's fine\n  if (document && document.createElement) {\n    const el = document.createElement(\"div\")\n    el.innerText = x\n    return el.innerHTML\n  }\n*/\n\n  return String(x)\n    .replace(/&/g, '&amp;')\n    .replace(/\"/g, '&quot;')\n    .replace(/'/g, '&#39;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n}\n\nfunction tocPlugin (md, options) {\n  options = Object.assign({}, {\n    placeholder: '(\\\\$\\\\{toc\\\\}|\\\\[\\\\[?_?toc_?\\\\]?\\\\]|\\\\$\\\\<toc(\\\\{[^}]*\\\\})\\\\>)',\n    slugify: slugify,\n    uniqueSlugStartIndex: 1,\n    containerClass: 'table-of-contents',\n    containerId: undefined,\n    listClass: undefined,\n    itemClass: undefined,\n    linkClass: undefined,\n    level: 1,\n    listType: 'ol',\n    format: undefined,\n    callback: undefined/* function(html, ast) {} */\n  }, options)\n\n  let ast\n  const pattern = new RegExp('^' + options.placeholder + '$', 'i')\n\n  function toc (state, startLine, endLine, silent) {\n    let token\n    const pos = state.bMarks[startLine] + state.tShift[startLine]\n    const max = state.eMarks[startLine]\n\n    // use whitespace as a line tokenizer and extract the first token\n    // to test against the placeholder anchored pattern, rejecting if false\n    const lineFirstToken = state.src.slice(pos, max).split(' ')[0]\n    if (!pattern.test(lineFirstToken)) return false\n\n    if (silent) return true\n\n    const matches = pattern.exec(lineFirstToken)\n    let inlineOptions = {}\n    if (matches !== null && matches.length === 3) {\n      try {\n        inlineOptions = JSON.parse(matches[2])\n      } catch (ex) {\n        // silently ignore inline options\n      }\n    }\n\n    state.line = startLine + 1\n\n    token = state.push('tocOpen', 'nav', 1)\n    token.markup = ''\n    token.map = [startLine, state.line]\n    token.inlineOptions = inlineOptions\n\n    token = state.push('tocBody', '', 0)\n    token.markup = ''\n    token.map = [startLine, state.line]\n    token.inlineOptions = inlineOptions\n    token.children = []\n\n    token = state.push('tocClose', 'nav', -1)\n    token.markup = ''\n\n    return true\n  }\n\n  md.renderer.rules.tocOpen = function (tokens, idx/* , options, env, renderer */) {\n    let _options = Object.assign({}, options)\n    if (tokens && idx >= 0) {\n      const token = tokens[idx]\n      _options = Object.assign(_options, token.inlineOptions)\n    }\n    const id = _options.containerId ? ` id=\"${htmlencode(_options.containerId)}\"` : ''\n    return `<nav${id} class=\"${htmlencode(_options.containerClass)}\">`\n  }\n\n  md.renderer.rules.tocClose = function (/* tokens, idx, options, env, renderer */) {\n    return '</nav>'\n  }\n\n  md.renderer.rules.tocBody = function (tokens, idx/* , options, env, renderer */) {\n    let _options = Object.assign({}, options)\n    if (tokens && idx >= 0) {\n      const token = tokens[idx]\n      _options = Object.assign(_options, token.inlineOptions)\n    }\n\n    const uniques = {}\n    function unique (s) {\n      let u = s\n      let i = _options.uniqueSlugStartIndex\n      while (Object.prototype.hasOwnProperty.call(uniques, u)) u = `${s}-${i++}`\n      uniques[u] = true\n      return u\n    }\n\n    const isLevelSelectedNumber = selection => level => level >= selection\n    const isLevelSelectedArray = selection => level => selection.includes(level)\n\n    const isLevelSelected = Array.isArray(_options.level)\n      ? isLevelSelectedArray(_options.level)\n      : isLevelSelectedNumber(_options.level)\n\n    function ast2html (tree) {\n      const listClass = _options.listClass ? ` class=\"${htmlencode(_options.listClass)}\"` : ''\n      const itemClass = _options.itemClass ? ` class=\"${htmlencode(_options.itemClass)}\"` : ''\n      const linkClass = _options.linkClass ? ` class=\"${htmlencode(_options.linkClass)}\"` : ''\n\n      if (tree.c.length === 0) return ''\n\n      let buffer = ''\n      if (tree.l === 0 || isLevelSelected(tree.l)) {\n        buffer += (`<${htmlencode(_options.listType) + listClass}>`)\n      }\n      tree.c.forEach(node => {\n        if (isLevelSelected(node.l)) {\n          buffer += (`<li${itemClass}><a${linkClass} href=\"#${unique(options.slugify(node.n))}\">${typeof _options.format === 'function' ? _options.format(node.n, htmlencode) : htmlencode(node.n)}</a>${ast2html(node)}</li>`)\n        } else {\n          buffer += ast2html(node)\n        }\n      })\n      if (tree.l === 0 || isLevelSelected(tree.l)) {\n        buffer += (`</${htmlencode(_options.listType)}>`)\n      }\n      return buffer\n    }\n\n    return ast2html(ast)\n  }\n\n  function headings2ast (tokens) {\n    const ast = { l: 0, n: '', c: [] }\n    const stack = [ast]\n\n    for (let i = 0, iK = tokens.length; i < iK; i++) {\n      const token = tokens[i]\n      if (token.type === 'heading_open') {\n        const key = (\n          tokens[i + 1]\n            .children\n            .filter(function (token) { return token.type === 'text' || token.type === 'code_inline' || token.type === 'emoji' })\n            .reduce(function (s, t) { return s + t.content }, '')\n        )\n\n        const node = {\n          l: parseInt(token.tag.substr(1), 10),\n          n: key,\n          c: []\n        }\n\n        if (node.l > stack[0].l) {\n          stack[0].c.push(node)\n          stack.unshift(node)\n        } else if (node.l === stack[0].l) {\n          stack[1].c.push(node)\n          stack[0] = node\n        } else {\n          while (node.l <= stack[0].l) stack.shift()\n          stack[0].c.push(node)\n          stack.unshift(node)\n        }\n      }\n    }\n\n    return ast\n  }\n\n  md.core.ruler.push('generateTocAst', function (state) {\n    const tokens = state.tokens\n    ast = headings2ast(tokens)\n\n    if (typeof options.callback === 'function') {\n      options.callback(\n        md.renderer.rules.tocOpen() + md.renderer.rules.tocBody() + md.renderer.rules.tocClose(),\n        ast\n      )\n    }\n  })\n\n  md.block.ruler.before('heading', 'toc', toc, {\n    alt: ['paragraph', 'reference', 'blockquote']\n  })\n}\n\nexport default tocPlugin\n"],"names":["slugify","x","encodeURIComponent","String","trim","toLowerCase","replace","htmlencode","md","options","ast","Object","assign","placeholder","uniqueSlugStartIndex","containerClass","containerId","undefined","listClass","itemClass","linkClass","level","listType","format","callback","pattern","RegExp","renderer","rules","tocOpen","tokens","idx","_options","inlineOptions","tocClose","tocBody","uniques","isLevelSelected","Array","isArray","selection","includes","isLevelSelectedNumber","ast2html","tree","c","length","buffer","l","forEach","node","s","u","i","prototype","hasOwnProperty","call","unique","n","core","ruler","push","state","stack","iK","token","type","key","children","filter","reduce","t","content","parseInt","tag","substr","unshift","shift","headings2ast","block","before","startLine","endLine","silent","lineFirstToken","src","slice","bMarks","tShift","eMarks","split","test","matches","exec","JSON","parse","ex","line","markup","map","alt"],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/markdownItTocDoneRight.umd.js b/dist/markdownItTocDoneRight.umd.js
index aaddc06bc53c86d22a767652cfd3ef9cd478823e..dd81957a39a2fc3e411f6c8c5689cbd71c50b198 100644
--- a/dist/markdownItTocDoneRight.umd.js
+++ b/dist/markdownItTocDoneRight.umd.js
@@ -1,2 +1,2 @@
-!function(e,n){"object"==typeof exports&&"undefined"!=typeof module?module.exports=n():"function"==typeof define&&define.amd?define(n):(e=e||self).markdownItTocDoneRight=n()}(this,function(){function e(e){return encodeURIComponent(String(e).trim().toLowerCase().replace(/\s+/g,"-"))}function n(e){return String(e).replace(/&/g,"&amp;").replace(/"/g,"&quot;").replace(/'/g,"&#39;").replace(/</g,"&lt;").replace(/>/g,"&gt;")}return function(t,r){var l;r=Object.assign({},{placeholder:"(\\$\\{toc\\}|\\[\\[?_?toc_?\\]?\\]|\\$\\<toc(\\{[^}]*\\})\\>)",slugify:e,uniqueSlugStartIndex:1,containerClass:"table-of-contents",containerId:void 0,listClass:void 0,itemClass:void 0,linkClass:void 0,level:1,listType:"ol",format:void 0,callback:void 0},r);var i=new RegExp("^"+r.placeholder+"$","i");t.renderer.rules.tocOpen=function(e,t){var l=Object.assign({},r);return e&&t>=0&&(l=Object.assign(l,e[t].inlineOptions)),"<nav"+(l.containerId?' id="'+n(l.containerId)+'"':"")+' class="'+n(l.containerClass)+'">'},t.renderer.rules.tocClose=function(){return"</nav>"},t.renderer.rules.tocBody=function(e,t){var i=Object.assign({},r);e&&t>=0&&(i=Object.assign(i,e[t].inlineOptions));var o,s={},c=Array.isArray(i.level)?(o=i.level,function(e){return o.includes(e)}):function(e){return function(n){return n>=e}}(i.level);return function e(t){var l=i.listClass?' class="'+n(i.listClass)+'"':"",o=i.itemClass?' class="'+n(i.itemClass)+'"':"",a=i.linkClass?' class="'+n(i.linkClass)+'"':"";if(0===t.c.length)return"";var u="";return(0===t.l||c(t.l))&&(u+="<"+(n(i.listType)+l)+">"),t.c.forEach(function(t){c(t.l)?u+="<li"+o+"><a"+a+' href="#'+function(e){for(var n=e,t=i.uniqueSlugStartIndex;Object.prototype.hasOwnProperty.call(s,n);)n=e+"-"+t++;return s[n]=!0,n}(r.slugify(t.n))+'">'+("function"==typeof i.format?i.format(t.n,n):n(t.n))+"</a>"+e(t)+"</li>":u+=e(t)}),(0===t.l||c(t.l))&&(u+="</"+n(i.listType)+">"),u}(l)},t.core.ruler.push("generateTocAst",function(e){l=function(e){for(var n={l:0,n:"",c:[]},t=[n],r=0,l=e.length;r<l;r++){var i=e[r];if("heading_open"===i.type){var o=e[r+1].children.filter(function(e){return"text"===e.type||"code_inline"===e.type}).reduce(function(e,n){return e+n.content},""),s={l:parseInt(i.tag.substr(1),10),n:o,c:[]};if(s.l>t[0].l)t[0].c.push(s),t.unshift(s);else if(s.l===t[0].l)t[1].c.push(s),t[0]=s;else{for(;s.l<=t[0].l;)t.shift();t[0].c.push(s),t.unshift(s)}}}return n}(e.tokens),"function"==typeof r.callback&&r.callback(t.renderer.rules.tocOpen()+t.renderer.rules.tocBody()+t.renderer.rules.tocClose(),l)}),t.block.ruler.before("heading","toc",function(e,n,t,r){var l,o=e.src.slice(e.bMarks[n]+e.tShift[n],e.eMarks[n]).split(" ")[0];if(!i.test(o))return!1;if(r)return!0;var s=i.exec(o),c={};if(null!==s&&3===s.length)try{c=JSON.parse(s[2])}catch(e){}return e.line=n+1,(l=e.push("tocOpen","nav",1)).markup="",l.map=[n,e.line],l.inlineOptions=c,(l=e.push("tocBody","",0)).markup="",l.map=[n,e.line],l.inlineOptions=c,l.children=[],(l=e.push("tocClose","nav",-1)).markup="",!0},{alt:["paragraph","reference","blockquote"]})}});
+!function(e,n){"object"==typeof exports&&"undefined"!=typeof module?module.exports=n():"function"==typeof define&&define.amd?define(n):(e=e||self).markdownItTocDoneRight=n()}(this,function(){function e(e){return encodeURIComponent(String(e).trim().toLowerCase().replace(/\s+/g,"-"))}function n(e){return String(e).replace(/&/g,"&amp;").replace(/"/g,"&quot;").replace(/'/g,"&#39;").replace(/</g,"&lt;").replace(/>/g,"&gt;")}return function(t,r){var l;r=Object.assign({},{placeholder:"(\\$\\{toc\\}|\\[\\[?_?toc_?\\]?\\]|\\$\\<toc(\\{[^}]*\\})\\>)",slugify:e,uniqueSlugStartIndex:1,containerClass:"table-of-contents",containerId:void 0,listClass:void 0,itemClass:void 0,linkClass:void 0,level:1,listType:"ol",format:void 0,callback:void 0},r);var i=new RegExp("^"+r.placeholder+"$","i");t.renderer.rules.tocOpen=function(e,t){var l=Object.assign({},r);return e&&t>=0&&(l=Object.assign(l,e[t].inlineOptions)),"<nav"+(l.containerId?' id="'+n(l.containerId)+'"':"")+' class="'+n(l.containerClass)+'">'},t.renderer.rules.tocClose=function(){return"</nav>"},t.renderer.rules.tocBody=function(e,t){var i=Object.assign({},r);e&&t>=0&&(i=Object.assign(i,e[t].inlineOptions));var o,s={},c=Array.isArray(i.level)?(o=i.level,function(e){return o.includes(e)}):function(e){return function(n){return n>=e}}(i.level);return function e(t){var l=i.listClass?' class="'+n(i.listClass)+'"':"",o=i.itemClass?' class="'+n(i.itemClass)+'"':"",a=i.linkClass?' class="'+n(i.linkClass)+'"':"";if(0===t.c.length)return"";var u="";return(0===t.l||c(t.l))&&(u+="<"+(n(i.listType)+l)+">"),t.c.forEach(function(t){c(t.l)?u+="<li"+o+"><a"+a+' href="#'+function(e){for(var n=e,t=i.uniqueSlugStartIndex;Object.prototype.hasOwnProperty.call(s,n);)n=e+"-"+t++;return s[n]=!0,n}(r.slugify(t.n))+'">'+("function"==typeof i.format?i.format(t.n,n):n(t.n))+"</a>"+e(t)+"</li>":u+=e(t)}),(0===t.l||c(t.l))&&(u+="</"+n(i.listType)+">"),u}(l)},t.core.ruler.push("generateTocAst",function(e){l=function(e){for(var n={l:0,n:"",c:[]},t=[n],r=0,l=e.length;r<l;r++){var i=e[r];if("heading_open"===i.type){var o=e[r+1].children.filter(function(e){return"text"===e.type||"code_inline"===e.type||"emoji"===e.type}).reduce(function(e,n){return e+n.content},""),s={l:parseInt(i.tag.substr(1),10),n:o,c:[]};if(s.l>t[0].l)t[0].c.push(s),t.unshift(s);else if(s.l===t[0].l)t[1].c.push(s),t[0]=s;else{for(;s.l<=t[0].l;)t.shift();t[0].c.push(s),t.unshift(s)}}}return n}(e.tokens),"function"==typeof r.callback&&r.callback(t.renderer.rules.tocOpen()+t.renderer.rules.tocBody()+t.renderer.rules.tocClose(),l)}),t.block.ruler.before("heading","toc",function(e,n,t,r){var l,o=e.src.slice(e.bMarks[n]+e.tShift[n],e.eMarks[n]).split(" ")[0];if(!i.test(o))return!1;if(r)return!0;var s=i.exec(o),c={};if(null!==s&&3===s.length)try{c=JSON.parse(s[2])}catch(e){}return e.line=n+1,(l=e.push("tocOpen","nav",1)).markup="",l.map=[n,e.line],l.inlineOptions=c,(l=e.push("tocBody","",0)).markup="",l.map=[n,e.line],l.inlineOptions=c,l.children=[],(l=e.push("tocClose","nav",-1)).markup="",!0},{alt:["paragraph","reference","blockquote"]})}});
 //# sourceMappingURL=markdownItTocDoneRight.umd.js.map
diff --git a/dist/markdownItTocDoneRight.umd.js.map b/dist/markdownItTocDoneRight.umd.js.map
index 1b1b8ddfae61416292ad1c59597b808036e288cf..44277ae433aec88dfae0938330ec669a520970e3 100644
--- a/dist/markdownItTocDoneRight.umd.js.map
+++ b/dist/markdownItTocDoneRight.umd.js.map
@@ -1 +1 @@
-{"version":3,"file":"markdownItTocDoneRight.umd.js","sources":["../index.js"],"sourcesContent":["'use strict'\n\nfunction slugify (x) {\n  return encodeURIComponent(String(x).trim().toLowerCase().replace(/\\s+/g, '-'))\n}\n\nfunction htmlencode (x) {\n/*\n  // safest, delegate task to native -- IMPORTANT: enabling this breaks both jest and runkit, but with browserify it's fine\n  if (document && document.createElement) {\n    const el = document.createElement(\"div\")\n    el.innerText = x\n    return el.innerHTML\n  }\n*/\n\n  return String(x)\n    .replace(/&/g, '&amp;')\n    .replace(/\"/g, '&quot;')\n    .replace(/'/g, '&#39;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n}\n\nfunction tocPlugin (md, options) {\n  options = Object.assign({}, {\n    placeholder: '(\\\\$\\\\{toc\\\\}|\\\\[\\\\[?_?toc_?\\\\]?\\\\]|\\\\$\\\\<toc(\\\\{[^}]*\\\\})\\\\>)',\n    slugify: slugify,\n    uniqueSlugStartIndex: 1,\n    containerClass: 'table-of-contents',\n    containerId: undefined,\n    listClass: undefined,\n    itemClass: undefined,\n    linkClass: undefined,\n    level: 1,\n    listType: 'ol',\n    format: undefined,\n    callback: undefined/* function(html, ast) {} */\n  }, options)\n\n  let ast\n  const pattern = new RegExp('^' + options.placeholder + '$', 'i')\n\n  function toc (state, startLine, endLine, silent) {\n    let token\n    const pos = state.bMarks[startLine] + state.tShift[startLine]\n    const max = state.eMarks[startLine]\n\n    // use whitespace as a line tokenizer and extract the first token\n    // to test against the placeholder anchored pattern, rejecting if false\n    const lineFirstToken = state.src.slice(pos, max).split(' ')[0]\n    if (!pattern.test(lineFirstToken)) return false\n\n    if (silent) return true\n\n    const matches = pattern.exec(lineFirstToken)\n    let inlineOptions = {}\n    if (matches !== null && matches.length === 3) {\n      try {\n        inlineOptions = JSON.parse(matches[2])\n      } catch (ex) {\n        // silently ignore inline options\n      }\n    }\n\n    state.line = startLine + 1\n\n    token = state.push('tocOpen', 'nav', 1)\n    token.markup = ''\n    token.map = [startLine, state.line]\n    token.inlineOptions = inlineOptions\n\n    token = state.push('tocBody', '', 0)\n    token.markup = ''\n    token.map = [startLine, state.line]\n    token.inlineOptions = inlineOptions\n    token.children = []\n\n    token = state.push('tocClose', 'nav', -1)\n    token.markup = ''\n\n    return true\n  }\n\n  md.renderer.rules.tocOpen = function (tokens, idx/* , options, env, renderer */) {\n    let _options = Object.assign({}, options)\n    if (tokens && idx >= 0) {\n      const token = tokens[idx]\n      _options = Object.assign(_options, token.inlineOptions)\n    }\n    const id = _options.containerId ? ` id=\"${htmlencode(_options.containerId)}\"` : ''\n    return `<nav${id} class=\"${htmlencode(_options.containerClass)}\">`\n  }\n\n  md.renderer.rules.tocClose = function (/* tokens, idx, options, env, renderer */) {\n    return '</nav>'\n  }\n\n  md.renderer.rules.tocBody = function (tokens, idx/* , options, env, renderer */) {\n    let _options = Object.assign({}, options)\n    if (tokens && idx >= 0) {\n      const token = tokens[idx]\n      _options = Object.assign(_options, token.inlineOptions)\n    }\n\n    const uniques = {}\n    function unique (s) {\n      let u = s\n      let i = _options.uniqueSlugStartIndex\n      while (Object.prototype.hasOwnProperty.call(uniques, u)) u = `${s}-${i++}`\n      uniques[u] = true\n      return u\n    }\n\n    const isLevelSelectedNumber = selection => level => level >= selection\n    const isLevelSelectedArray = selection => level => selection.includes(level)\n\n    const isLevelSelected = Array.isArray(_options.level)\n      ? isLevelSelectedArray(_options.level)\n      : isLevelSelectedNumber(_options.level)\n\n    function ast2html (tree) {\n      const listClass = _options.listClass ? ` class=\"${htmlencode(_options.listClass)}\"` : ''\n      const itemClass = _options.itemClass ? ` class=\"${htmlencode(_options.itemClass)}\"` : ''\n      const linkClass = _options.linkClass ? ` class=\"${htmlencode(_options.linkClass)}\"` : ''\n\n      if (tree.c.length === 0) return ''\n\n      let buffer = ''\n      if (tree.l === 0 || isLevelSelected(tree.l)) {\n        buffer += (`<${htmlencode(_options.listType) + listClass}>`)\n      }\n      tree.c.forEach(node => {\n        if (isLevelSelected(node.l)) {\n          buffer += (`<li${itemClass}><a${linkClass} href=\"#${unique(options.slugify(node.n))}\">${typeof _options.format === 'function' ? _options.format(node.n, htmlencode) : htmlencode(node.n)}</a>${ast2html(node)}</li>`)\n        } else {\n          buffer += ast2html(node)\n        }\n      })\n      if (tree.l === 0 || isLevelSelected(tree.l)) {\n        buffer += (`</${htmlencode(_options.listType)}>`)\n      }\n      return buffer\n    }\n\n    return ast2html(ast)\n  }\n\n  function headings2ast (tokens) {\n    const ast = { l: 0, n: '', c: [] }\n    const stack = [ast]\n\n    for (let i = 0, iK = tokens.length; i < iK; i++) {\n      const token = tokens[i]\n      if (token.type === 'heading_open') {\n        const key = (\n          tokens[i + 1]\n            .children\n            .filter(function (token) { return token.type === 'text' || token.type === 'code_inline' })\n            .reduce(function (s, t) { return s + t.content }, '')\n        )\n\n        const node = {\n          l: parseInt(token.tag.substr(1), 10),\n          n: key,\n          c: []\n        }\n\n        if (node.l > stack[0].l) {\n          stack[0].c.push(node)\n          stack.unshift(node)\n        } else if (node.l === stack[0].l) {\n          stack[1].c.push(node)\n          stack[0] = node\n        } else {\n          while (node.l <= stack[0].l) stack.shift()\n          stack[0].c.push(node)\n          stack.unshift(node)\n        }\n      }\n    }\n\n    return ast\n  }\n\n  md.core.ruler.push('generateTocAst', function (state) {\n    const tokens = state.tokens\n    ast = headings2ast(tokens)\n\n    if (typeof options.callback === 'function') {\n      options.callback(\n        md.renderer.rules.tocOpen() + md.renderer.rules.tocBody() + md.renderer.rules.tocClose(),\n        ast\n      )\n    }\n  })\n\n  md.block.ruler.before('heading', 'toc', toc, {\n    alt: ['paragraph', 'reference', 'blockquote']\n  })\n}\n\nexport default tocPlugin\n"],"names":["slugify","x","encodeURIComponent","String","trim","toLowerCase","replace","htmlencode","md","options","ast","Object","assign","placeholder","uniqueSlugStartIndex","containerClass","containerId","undefined","listClass","itemClass","linkClass","level","listType","format","callback","pattern","RegExp","renderer","rules","tocOpen","tokens","idx","_options","inlineOptions","tocClose","tocBody","selection","uniques","isLevelSelected","Array","isArray","includes","isLevelSelectedNumber","ast2html","tree","c","length","buffer","l","forEach","node","s","u","i","prototype","hasOwnProperty","call","unique","n","core","ruler","push","state","stack","iK","token","type","key","children","filter","reduce","t","content","parseInt","tag","substr","unshift","shift","headings2ast","block","before","startLine","endLine","silent","lineFirstToken","src","slice","bMarks","tShift","eMarks","split","test","matches","exec","JSON","parse","ex","line","markup","map","alt"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"markdownItTocDoneRight.umd.js","sources":["../index.js"],"sourcesContent":["'use strict'\n\nfunction slugify (x) {\n  return encodeURIComponent(String(x).trim().toLowerCase().replace(/\\s+/g, '-'))\n}\n\nfunction htmlencode (x) {\n/*\n  // safest, delegate task to native -- IMPORTANT: enabling this breaks both jest and runkit, but with browserify it's fine\n  if (document && document.createElement) {\n    const el = document.createElement(\"div\")\n    el.innerText = x\n    return el.innerHTML\n  }\n*/\n\n  return String(x)\n    .replace(/&/g, '&amp;')\n    .replace(/\"/g, '&quot;')\n    .replace(/'/g, '&#39;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n}\n\nfunction tocPlugin (md, options) {\n  options = Object.assign({}, {\n    placeholder: '(\\\\$\\\\{toc\\\\}|\\\\[\\\\[?_?toc_?\\\\]?\\\\]|\\\\$\\\\<toc(\\\\{[^}]*\\\\})\\\\>)',\n    slugify: slugify,\n    uniqueSlugStartIndex: 1,\n    containerClass: 'table-of-contents',\n    containerId: undefined,\n    listClass: undefined,\n    itemClass: undefined,\n    linkClass: undefined,\n    level: 1,\n    listType: 'ol',\n    format: undefined,\n    callback: undefined/* function(html, ast) {} */\n  }, options)\n\n  let ast\n  const pattern = new RegExp('^' + options.placeholder + '$', 'i')\n\n  function toc (state, startLine, endLine, silent) {\n    let token\n    const pos = state.bMarks[startLine] + state.tShift[startLine]\n    const max = state.eMarks[startLine]\n\n    // use whitespace as a line tokenizer and extract the first token\n    // to test against the placeholder anchored pattern, rejecting if false\n    const lineFirstToken = state.src.slice(pos, max).split(' ')[0]\n    if (!pattern.test(lineFirstToken)) return false\n\n    if (silent) return true\n\n    const matches = pattern.exec(lineFirstToken)\n    let inlineOptions = {}\n    if (matches !== null && matches.length === 3) {\n      try {\n        inlineOptions = JSON.parse(matches[2])\n      } catch (ex) {\n        // silently ignore inline options\n      }\n    }\n\n    state.line = startLine + 1\n\n    token = state.push('tocOpen', 'nav', 1)\n    token.markup = ''\n    token.map = [startLine, state.line]\n    token.inlineOptions = inlineOptions\n\n    token = state.push('tocBody', '', 0)\n    token.markup = ''\n    token.map = [startLine, state.line]\n    token.inlineOptions = inlineOptions\n    token.children = []\n\n    token = state.push('tocClose', 'nav', -1)\n    token.markup = ''\n\n    return true\n  }\n\n  md.renderer.rules.tocOpen = function (tokens, idx/* , options, env, renderer */) {\n    let _options = Object.assign({}, options)\n    if (tokens && idx >= 0) {\n      const token = tokens[idx]\n      _options = Object.assign(_options, token.inlineOptions)\n    }\n    const id = _options.containerId ? ` id=\"${htmlencode(_options.containerId)}\"` : ''\n    return `<nav${id} class=\"${htmlencode(_options.containerClass)}\">`\n  }\n\n  md.renderer.rules.tocClose = function (/* tokens, idx, options, env, renderer */) {\n    return '</nav>'\n  }\n\n  md.renderer.rules.tocBody = function (tokens, idx/* , options, env, renderer */) {\n    let _options = Object.assign({}, options)\n    if (tokens && idx >= 0) {\n      const token = tokens[idx]\n      _options = Object.assign(_options, token.inlineOptions)\n    }\n\n    const uniques = {}\n    function unique (s) {\n      let u = s\n      let i = _options.uniqueSlugStartIndex\n      while (Object.prototype.hasOwnProperty.call(uniques, u)) u = `${s}-${i++}`\n      uniques[u] = true\n      return u\n    }\n\n    const isLevelSelectedNumber = selection => level => level >= selection\n    const isLevelSelectedArray = selection => level => selection.includes(level)\n\n    const isLevelSelected = Array.isArray(_options.level)\n      ? isLevelSelectedArray(_options.level)\n      : isLevelSelectedNumber(_options.level)\n\n    function ast2html (tree) {\n      const listClass = _options.listClass ? ` class=\"${htmlencode(_options.listClass)}\"` : ''\n      const itemClass = _options.itemClass ? ` class=\"${htmlencode(_options.itemClass)}\"` : ''\n      const linkClass = _options.linkClass ? ` class=\"${htmlencode(_options.linkClass)}\"` : ''\n\n      if (tree.c.length === 0) return ''\n\n      let buffer = ''\n      if (tree.l === 0 || isLevelSelected(tree.l)) {\n        buffer += (`<${htmlencode(_options.listType) + listClass}>`)\n      }\n      tree.c.forEach(node => {\n        if (isLevelSelected(node.l)) {\n          buffer += (`<li${itemClass}><a${linkClass} href=\"#${unique(options.slugify(node.n))}\">${typeof _options.format === 'function' ? _options.format(node.n, htmlencode) : htmlencode(node.n)}</a>${ast2html(node)}</li>`)\n        } else {\n          buffer += ast2html(node)\n        }\n      })\n      if (tree.l === 0 || isLevelSelected(tree.l)) {\n        buffer += (`</${htmlencode(_options.listType)}>`)\n      }\n      return buffer\n    }\n\n    return ast2html(ast)\n  }\n\n  function headings2ast (tokens) {\n    const ast = { l: 0, n: '', c: [] }\n    const stack = [ast]\n\n    for (let i = 0, iK = tokens.length; i < iK; i++) {\n      const token = tokens[i]\n      if (token.type === 'heading_open') {\n        const key = (\n          tokens[i + 1]\n            .children\n            .filter(function (token) { return token.type === 'text' || token.type === 'code_inline' || token.type === 'emoji' })\n            .reduce(function (s, t) { return s + t.content }, '')\n        )\n\n        const node = {\n          l: parseInt(token.tag.substr(1), 10),\n          n: key,\n          c: []\n        }\n\n        if (node.l > stack[0].l) {\n          stack[0].c.push(node)\n          stack.unshift(node)\n        } else if (node.l === stack[0].l) {\n          stack[1].c.push(node)\n          stack[0] = node\n        } else {\n          while (node.l <= stack[0].l) stack.shift()\n          stack[0].c.push(node)\n          stack.unshift(node)\n        }\n      }\n    }\n\n    return ast\n  }\n\n  md.core.ruler.push('generateTocAst', function (state) {\n    const tokens = state.tokens\n    ast = headings2ast(tokens)\n\n    if (typeof options.callback === 'function') {\n      options.callback(\n        md.renderer.rules.tocOpen() + md.renderer.rules.tocBody() + md.renderer.rules.tocClose(),\n        ast\n      )\n    }\n  })\n\n  md.block.ruler.before('heading', 'toc', toc, {\n    alt: ['paragraph', 'reference', 'blockquote']\n  })\n}\n\nexport default tocPlugin\n"],"names":["slugify","x","encodeURIComponent","String","trim","toLowerCase","replace","htmlencode","md","options","ast","Object","assign","placeholder","uniqueSlugStartIndex","containerClass","containerId","undefined","listClass","itemClass","linkClass","level","listType","format","callback","pattern","RegExp","renderer","rules","tocOpen","tokens","idx","_options","inlineOptions","tocClose","tocBody","selection","uniques","isLevelSelected","Array","isArray","includes","isLevelSelectedNumber","ast2html","tree","c","length","buffer","l","forEach","node","s","u","i","prototype","hasOwnProperty","call","unique","n","core","ruler","push","state","stack","iK","token","type","key","children","filter","reduce","t","content","parseInt","tag","substr","unshift","shift","headings2ast","block","before","startLine","endLine","silent","lineFirstToken","src","slice","bMarks","tShift","eMarks","split","test","matches","exec","JSON","parse","ex","line","markup","map","alt"],"mappings":"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"}
\ No newline at end of file
diff --git a/types/index.d.ts b/types/index.d.ts
index 098f06a388c73b82dc1247bcdd360bba45b35488..7537832d54d66bcac40343bd99c3e618c821bde2 100644
--- a/types/index.d.ts
+++ b/types/index.d.ts
@@ -1,5 +1,5 @@
 declare module 'markdown-it-toc-done-right' {
-    import MarkdownIt from 'markdown-it/lib'
+    import type { PluginWithOptions } from 'markdown-exit'
 
     export interface TocOptions {
         placeholder: string
@@ -22,7 +22,7 @@ declare module 'markdown-it-toc-done-right' {
         c: TocAst[]
     }
 
-    const markdownItTocDoneRight: MarkdownIt.PluginWithOptions<Partial<TocOptions>>
+    const markdownItTocDoneRight: PluginWithOptions<Partial<TocOptions>>
 
     export default markdownItTocDoneRight
 }
